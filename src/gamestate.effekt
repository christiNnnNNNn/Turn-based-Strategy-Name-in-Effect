
import src/model
import src/combat
import src/movement
import src/utils
import src/weaponhandling

type UIAction {
  Quit()
  SelectUnit(x: Int, y: Int)
  ShowMovement()
  SwitchWeapon(index: Int)
  MoveCursor(dx: Int, dy: Int)
  CancelMove()
  ConfirmMove() 
  ListTargets()       
  ConfirmCombat()     
  CancelCombat() 
  EndTurn()
  Help()     
  }

record CombatState(
  attacker: gameUnbit,
  attackerStartX: Int,
  attackerStartY: Int,
  attackerX: Int,
  attackerY: Int,
  defender: gameUnbit,
  wAtt: Weapon,
  wDef: Weapon,
  preview: CombatPreview
)

type MoveState {
  Moving(
    unit: gameUnbit,
    startX: Int,
    startY: Int,
    curX: Int,
    curY: Int,
    remaining: Int
  )
}

def replaceUnit(
  units: List[gameUnbit],
  oldX: Int,
  oldY: Int,
  updated: gameUnbit
): List[gameUnbit] =
  units match {
    case Nil() => Nil()

    case Cons(u, rest) =>
      if (u.x == oldX && u.y == oldY)
        Cons(updated, rest)
      else
        Cons(u, replaceUnit(rest, oldX, oldY, updated))
  }

def resetMoved(units: List[gameUnbit]): List[gameUnbit] =
  units match {
    case Nil() => Nil()
    case Cons(u, rest) =>
      val u2 =
        if (u.side == "player") setMoved(u, false)
        else u
      Cons(u2, resetMoved(rest))
  }

def effectivePosition(
  selected: Option[gameUnbit],
  moveState: Option[MoveState]
): Option[(gameUnbit, Int, Int)] =
  moveState match {
    case Some(Moving(u, _, _, cx, cy, _)) =>
      Some((u, cx, cy))
    case None() =>
      selected match {
        case Some(u) => Some((u, u.x, u.y))
        case None()  => None()
      }
  }

def nearestPlayer(enemy: gameUnbit, units: List[gameUnbit]): Option[gameUnbit] = {
  def loop(
    xs: List[gameUnbit],
    best: Option[gameUnbit],
    bestD: Int
  ): Option[gameUnbit] =
    xs match {
      case Nil() => best
      case Cons(u, rest) =>
        if (u.side == "player") {
          val d = manhattan(enemy.x, enemy.y, u.x, u.y)
          best match {
            case None() => loop(rest, Some(u), d)
            case Some(_) =>
              if (d < bestD)
                loop(rest, Some(u), d)
              else
                loop(rest, best, bestD)
          }
        } else
          loop(rest, best, bestD)
    }

  loop(units, None(), 999999)
}

def resolveAttackPure(att: gameUnbit, deff: gameUnbit, p: CombatPreview): AttackResult / {} =
  try { resolveAttack(att, deff, p) }
  with roll { max =>
    val m: Int = if (max <= 0) 1 else max
    resume(randInt(m))
  }

def bestReachForRange(
  reach: List[TilePos],
  tx: Int, ty: Int,
  rmin: Int, rmax: Int
): Option[TilePos] = {
  def loop(
    rs: List[TilePos],
    best: Option[TilePos],
    bestScore: Int,
    bestDist: Int
  ): Option[TilePos] =
    rs match {
      case Nil() => best
      case Cons(p, rest) =>
        val d = manhattan(p.x, p.y, tx, ty)

        val score =
          if (d < rmin) rmin - d
          else if (d > rmax) d - rmax
          else 0

        best match {
          case None() =>
            loop(rest, Some(p), score, d)

          case Some(_) =>
            if (score < bestScore || (score == bestScore && d < bestDist))
              loop(rest, Some(p), score, d)
            else
              loop(rest, best, bestScore, bestDist)
        }
    }

  loop(reach, None(), 999999, 999999)
}
def endOrContinue(map: GameMap) { next: GameMap => Unit }: Unit =
  val m = cleanupMap(map)
  val pAlive = sideHasUnits(m.units, "player")
  val eAlive = sideHasUnits(m.units, "enemy")

  if (pAlive && eAlive) next(m)
  else if (pAlive) { printString("\n*** YOU WIN! ***\n"); () }
  else { printString("\n*** YOU LOSE! ***\n"); () }


 def canCounter(
  defU: gameUnbit,
  attU: gameUnbit,
  wDef: Weapon
): Bool =
  val (rmin, rmax) = wDef.range
  val d = manhattan(defU.x, defU.y, attU.x, attU.y)
  d >= rmin && d <= rmax



  def bestReachToward(reach: List[TilePos], tx: Int, ty: Int): Option[TilePos] =
  {def loop(rs: List[TilePos], best: Option[TilePos], bestD: Int): Option[TilePos] =
    rs match {
      case Nil() => best
      case Cons(p, rest) =>
        val d = manhattan(p.x, p.y, tx, ty)
        best match {
          case None() => loop(rest, Some(p), d)
          case Some(_) =>
            if (d < bestD) loop(rest, Some(p), d) else loop(rest, best, bestD)
        }
    }
  loop(reach, None(), 999999)
  }

def isPlayer(u: gameUnbit): Bool = u.side == "player"

def isEnemy(u: gameUnbit): Bool = u.side == "enemy"

def removeDead(units: List[gameUnbit]): List[gameUnbit] =
  units match {
    case Nil() => Nil()
    case Cons(u, rest) =>
      val tail = removeDead(rest)
      if (alive(u)) Cons(u, tail) else tail
  }

def cleanupMap(m: GameMap): GameMap =
  GameMap(m.width, m.height, m.tiles, removeDead(m.units))

def sideHasUnits(units: List[gameUnbit], side: String): Bool =
  units match {
    case Nil() => false
    case Cons(u, rest) =>
      if (u.side == side && alive(u)) true
      else sideHasUnits(rest, side)
  }

  def enemyPhase(map: GameMap): GameMap = {

  def onlyPlayers(xs: List[gameUnbit]): List[gameUnbit] =
    xs match {
      case Nil() => Nil()
      case Cons(u, rest) =>
        if (isPlayer(u)) Cons(u, onlyPlayers(rest))
        else onlyPlayers(rest)
    }

  def stepEnemy(cur: GameMap, e0: gameUnbit): GameMap =
    cleanupMap(
    if (not(isEnemy(e0)) || not(alive(e0))) cur
    else {
      nearestPlayer(e0, cur.units) match {
        case None() => cur
        case Some(tgt) =>

          val reach = withGroundMovement(cur, e0)

          val destOpt =
            weaponhandling::activeWeapon(e0) match {
              case None() =>
                bestReachToward(reach, tgt.x, tgt.y)

              case Some(wE0) =>
                wE0.range match {
                  case (rmin, rmax) =>
                    bestReachForRange(reach, tgt.x, tgt.y, rmin, rmax)
                }
            }

          val e1 =
            destOpt match {
              case None() => e0
              case Some(TilePos(nx, ny)) => setPos(e0, nx, ny)
            }

          // commit movement
          val unitsMoved = replaceUnit(cur.units, e0.x, e0.y, e1)
          val mapMoved   = GameMap(cur.width, cur.height, cur.tiles, unitsMoved)

          // attack (enemy -> player)
          weaponhandling::activeWeapon(e1) match {
            case None() => mapMoved
            case Some(wE) =>
              val ts  = collectTargets(e1, e1.x, e1.y, mapMoved.units, wE)
              val ts2 = onlyPlayers(ts)

              ts2 match {
                case Nil() => mapMoved
                case Cons(defU, _) =>

                  // enemy strikes
                  weaponhandling::activeWeapon(defU) match {
                    case None() =>
                      val pE  = previewPure(mapMoved, e1, defU, wE, wE)
                      val r1  = resolveAttackPure(e1, defU, pE)
                      val def1 = applyDamage(defU, r1.damage)

                      printString(
                        "\nENEMY ATTACK: " ++
                        (if (r1.hit) "HIT" else "MISS") ++
                        (if (r1.crit) " (CRIT)" else "") ++
                        " dmg=" ++ r1.damage.show ++ "\n"
                      )

                      val unitsAfter = replaceUnit(mapMoved.units, defU.x, defU.y, def1)
                      GameMap(mapMoved.width, mapMoved.height, mapMoved.tiles, unitsAfter)

                    case Some(wP) =>
                      val pE  = previewPure(mapMoved, e1, defU, wE, wP)
                      val r1  = resolveAttackPure(e1, defU, pE)
                      val def1 = applyDamage(defU, r1.damage)

                      printString(
                        "\nENEMY ATTACK: " ++
                        (if (r1.hit) "HIT" else "MISS") ++
                        (if (r1.crit) " (CRIT)" else "") ++
                        " dmg=" ++ r1.damage.show ++ "\n"
                      )

                      val units1 = replaceUnit(mapMoved.units, defU.x, defU.y, def1)
                      val map1   = GameMap(mapMoved.width, mapMoved.height, mapMoved.tiles, units1)

                     
                      if (alive(def1) && canCounter(def1, e1, wP)) {

                        
                        val defCounter0 = decWeaponUse(def1)

                       
                        weaponhandling::activeWeapon(defCounter0) match {
                          case None() =>
                            map1

                          case Some(wPCur) =>
                            val pC = previewPure(map1, defCounter0, e1, wPCur, wE)
                            val r2 = resolveAttackPure(defCounter0, e1, pC)
                            val e2 = applyDamage(e1, r2.damage)

                            printString(
                              "PLAYER COUNTER: " ++
                              (if (r2.hit) "HIT" else "MISS") ++
                              (if (r2.crit) " (CRIT)" else "") ++
                              " dmg=" ++ r2.damage.show ++ "\n"
                            )

                            
                            val unitsA =
                              replaceUnit(map1.units, def1.x, def1.y, defCounter0)

                            
                            val unitsB =
                              replaceUnit(unitsA, e1.x, e1.y, e2)

                            GameMap(map1.width, map1.height, map1.tiles, unitsB)
                        }

                      } else {
                        map1
                      }
                  }
              }
          }
      }
    }
    )
    def loopEnemies(xs: List[gameUnbit], cur: GameMap): GameMap =
    xs match {
      case Nil() => cur
      case Cons(u, rest) =>
        // refresh unit from current map (it may have moved earlier)
        val uNow =
          unitAt(cur.units, u.x, u.y) match {
            case Some(u2) => u2
            case None()   => u
          }
        loopEnemies(rest, stepEnemy(cur, uNow))
    }

  loopEnemies(map.units, map)
}