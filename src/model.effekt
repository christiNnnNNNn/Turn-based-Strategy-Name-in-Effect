module model

type Tile {
  TileFloor()   // 'f' white/ neutral tile 
  TileWall()    // 'w' gray / impassable

  TileForest()  // 't' green, cost 3, defensive bonus
  TileSand()    // 's' yellow, cost 2
  TileHills()   // 'h' brown, cost 2, defensive bonus (different)
  TileMarsh()   // 'm' purple, cost 3, defensive debuff (higher hit)
}


type UnitClass {
  Soldier()
  Armor()
  Knight()
  Flyer()
}

type MoveMode {
  Foot()
  Heavy()
  Cavalry()
  Flying()
}

def showUnitClass(c: UnitClass): String =
  c match {
    case Soldier() => "Soldier"
    case Armor()   => "Armor"
    case Knight()  => "Knight"
    case Flyer()   => "Flyer"
  }
record gameUnbit(
  
  side: String,        // "player" or "enemy"

  x: Int,              // tile X position
  y: Int,              // tile Y position

  // --- Core stats ---
  hp: Int,             // Hit Points: how much damage the unit can take before dying

  strength: Int,       // Physical attack power (used for melee / physical damage)
  magic: Int,          // Magical attack power (used for spells and magic skills)

  defense: Int,        // Physical defense: reduces incoming physical damage
  resistance: Int,     // Magical defense: reduces incoming magic damage

  precision: Int,      // Accuracy: increases chance to hit enemies
  agility: Int,        // Evasion: decreases chance to be hit by enemies
  luck: Int,           // Luck: affects crit chance and crit avoidance

  movement: Int,       // Movement range per turn

  // --- Weapons ---
  weapons: List[Weapon], // All weapons the unit carries
  activeWeapon: Int,      // Index into weapons list (0-based)

  moved: Bool,
  symbol: String,  // the graphical idenfier off the unit on the map
  class: UnitClass
)




record GameMap(
  width: Int,
  height: Int,
  tiles: List[List[Tile]],
  units: List[gameUnbit]
)
// --- Weapon categories (for matchup rules later)
type WeaponKind {
  Sword()
  Axe()
  Lance()
  Bow()
  Tome()
}

// --- Is damage physical or magical?
type DamageType {
  Physical()
  Magic()
}

// --- Special effects that can be attached to weapons
type WeaponMod {
  NoneMod()
  ArmorBreak(amount: Int)     // flat defense reduction to defender in preview (and later apply as status)
  ExtraCrit(amount: Int)      // +crit
  MountedBonus(amount: Int)   // +damage if attacker is Knight
  AntiArmor(amount: Int)      // +damage vs Armor
}


// --- Weapon record
record Weapon(
  name: String,
  kind: WeaponKind,
  damageType: DamageType,
  attack: Int,
  hit: Int,        // percent 0..100
  uses: Int,       // remaining uses
  crit: Int,       // percent 0..100
  range:(Int,Int),
  mods: List[WeaponMod]
)
def getActiveWeapon(u: gameUnbit): Option[Weapon] = {
  def loop(ws: List[Weapon], i: Int): Option[Weapon] =
    ws match {
      case Nil() => None()
      case Cons(w, rest) =>
        if (i == 0) Some(w)
        else loop(rest, i - 1)
    }

  loop(u.weapons, u.activeWeapon)
}
def isAlive(u: gameUnbit): Bool =
  u.hp > 0

def removeDead(units: List[gameUnbit]): List[gameUnbit] =
  units match {
    case Nil() => Nil()
    case Cons(u, rest) =>
      val tail = removeDead(rest)
      if (isAlive(u)) Cons(u, tail) else tail
  }
def cleanupMap(m: GameMap): GameMap =
  GameMap(m.width, m.height, m.tiles, removeDead(m.units))
def sideHasUnits(units: List[gameUnbit], side: String): Bool =
  units match {
    case Nil() => false
    case Cons(u, rest) =>
      if (u.side == side && isAlive(u)) true
      else sideHasUnits(rest, side)
  }
