module model

type Tile {
  TileFloor()   // 'f' white/ neutral tile 
  TileWall()    // 'w' gray / impassable

  TileForest()  // 't' green, cost 3, defensive bonus
  TileSand()    // 's' yellow, cost 2
  TileHills()   // 'h' brown, cost 2, defensive bonus (different)
  TileMarsh()   // 'm' purple, cost 3, defensive debuff (higher hit)
}

type UnitClass {
  Soldier()
  Armor()
  Knight()
  Flyer()
}

//momvent type associated with a class
type MoveMode {
  Foot()
  Heavy()
  Cavalry()
  Flying()
}

def showUnitClass(c: UnitClass): String =
  c match {
    case Soldier() => "Soldier"
    case Armor()   => "Armor"
    case Knight()  => "Knight"
    case Flyer()   => "Flyer"
  }

record gameUnbit(

  side: String,        // "player" or "enemy"

  x: Int,              // tile X position
  y: Int,              // tile Y position

  // Core stats 
  hp: Int,             // Hit Points: how much damage the unit can take before dying

  strength: Int,       // Physical attack power (used for melee / physical damage)
  magic: Int,          // Magical attack power (used for spells and magic skills)

  defense: Int,        // Physical defense: reduces incoming physical damage
  resistance: Int,     // Magical defense: reduces incoming magic damage

  precision: Int,      // Accuracy: increases chance to hit enemies
  agility: Int,        // Evasion: decreases chance to be hit by enemies
  luck: Int,           // Luck: affects crit chance and crit avoidance

  movement: Int,       // Movement range per turn

  // Weapons
  weapons: List[Weapon], // All weapons the unit carries
  activeWeapon: Int,      // Index into weapons list (0-based)

  moved: Bool,
  symbol: String,  // the graphical idenfier off the unit on the map
  class: UnitClass
)

record GameMap(
  width: Int,
  height: Int,
  tiles: List[List[Tile]],
  units: List[gameUnbit]
)
// Weapon categories (for matchup rules later)
type WeaponKind {
  Sword()
  Axe()
  Lance()
  Bow()
  Tome()
}

// Is damage physical or magical?
type DamageType {
  Physical()
  Magic()
}

// Special effects that can be attached to weapons
type WeaponMod {
  NoneMod()
  ArmorBreak(amount: Int)     // flat defense reduction to defender in preview (and later apply as status)
  ExtraCrit(amount: Int)      // +crit
  MountedBonus(amount: Int)   // +damage if attacker is Knight
  AntiArmor(amount: Int)      // +damage vs Armor
}

// Weapon record
record Weapon(
  name: String,
  kind: WeaponKind,
  damageType: DamageType,
  attack: Int,
  hit: Int,        // percent 0..100
  uses: Int,       // remaining uses
  crit: Int,       // percent 0..100
  range:(Int,Int),
  mods: List[WeaponMod]
)

def setPos(u: gameUnbit, x: Int, y: Int): gameUnbit =
  gameUnbit(
    u.side, x, y,
    u.hp,
    u.strength, u.magic, u.defense, u.resistance,
    u.precision, u.agility, u.luck,
    u.movement,
    u.weapons, u.activeWeapon,
    u.moved,
    u.symbol,
    u.class
  )

def setHp(u: gameUnbit, hp: Int): gameUnbit =
  gameUnbit(
    u.side, u.x, u.y,
    hp,
    u.strength, u.magic, u.defense, u.resistance,
    u.precision, u.agility, u.luck,
    u.movement,
    u.weapons, u.activeWeapon,
    u.moved,
    u.symbol,
    u.class
  )

def setMoved(u: gameUnbit, moved: Bool): gameUnbit =
  gameUnbit(
    u.side, u.x, u.y,
    u.hp,
    u.strength, u.magic, u.defense, u.resistance,
    u.precision, u.agility, u.luck,
    u.movement,
    u.weapons, u.activeWeapon,
    moved,
    u.symbol,
    u.class
  )

def setWeapons(u: gameUnbit, weapons: List[Weapon], activeWeapon: Int): gameUnbit =
  gameUnbit(
    u.side, u.x, u.y,
    u.hp,
    u.strength, u.magic, u.defense, u.resistance,
    u.precision, u.agility, u.luck,
    u.movement,
    weapons, activeWeapon,
    u.moved,
    u.symbol,
    u.class
  )

  def setPosMoved(u: gameUnbit, x: Int, y: Int, moved: Bool): gameUnbit =
    setMoved(setPos(u, x, y), moved)