module maploader

import string
import list
import src/model

def rev[A](xs: List[A]): List[A] = reverse(xs)

def extractAt(line: String, pos: Int, key: String): String =
  line.substring(pos + key.length).trim()


def extract(line: String, key: String): String = {
  val idx = line.indexOf(key)

  if (idx is Some(i)) {
    extractAt(line, i, key)
  } else {
    ""
  }
}
def between(line: String, start: String, end: String): String = {
  val s = line.indexOf(start)
  val e = line.indexOf(end)

  (s, e) match {
    case (Some(si), Some(ei)) =>
      line.substring(si + start.length(), ei).trim()
    case _ =>
      ""
  }
}
def maxOption(list: List[Int]): Option[Int] =
  list.foldLeft(None()) { (acc, x) =>
    acc match {
      case None() => Some(x)
      case Some(m) => Some(if (x > m) x else m)
    }
  }

def toInt1(s: String): Int =
  if (s.length() == 0) 0
  else
    val first = s.substring(0, 1)   
    charToDigit(first)
def digit(c: String): Int =
  if (c == "0") 0
  else if (c == "1") 1
  else if (c == "2") 2
  else if (c == "3") 3
  else if (c == "4") 4
  else if (c == "5") 5
  else if (c == "6") 6
  else if (c == "7") 7
  else if (c == "8") 8
  else if (c == "9") 9
  else 0

def ptoInt(s: String): Int = {
  val t = s.trim()

  def loop(i: Int, acc: Int): Int =
    if (i >= t.length()) acc
    else {
      val ch = t.substring(i, i + 1)
      loop(i + 1, acc * 10 + digit(ch))
    }

  if (t.length() == 0) 0
  else if (t.substring(0, 1) == "-")
    0 - loop(1, 0)
  else
    loop(0, 0)
}


def charToDigit(c: String): Int =
  if (c == "0") 0
  else if (c == "1") 1
  else if (c == "2") 2
  else if (c == "3") 3
  else if (c == "4") 4
  else if (c == "5") 5
  else if (c == "6") 6
  else if (c == "7") 7
  else if (c == "8") 8
  else if (c == "9") 9
  else 0




def parseWeaponType(s: String): WeaponKind =
  if (s == "axe") Axe()
  else if (s == "sword") Sword()
  else if (s == "lance") Lance()
  else if (s == "bow") Bow()
  else Tome()

def parseDamageType(s: String): DamageType =
  if (s == "magical") Magic()
  else Physical()

def parseRange(s: String): (Int, Int) = {
  val comma = s.indexOf(",")
  comma match {
    case Some(i) =>
      val a = s.substring(0, i).trim()
      val b = s.substring(i + 1).trim()
      (ptoInt(a), ptoInt(b))
    case None() =>
      val x = ptoInt(s.trim())
      (x, x)
  }
}

def parseUnitClass(s: String): UnitClass =
  s.trim() match {
    case "soldier" => Soldier()
    case "armor"   => Armor()
    case "knight"  => Knight()
    case "flyer"   => Flyer()
    case _ =>

      Soldier()
  }

def parseMap(text: String): GameMap = {
  var height = 0

  val rows   = ref[List[List[Tile]]](Nil())
  val units  = ref[List[gameUnbit]](Nil())

  val curSide = ref[String]("")
  val curX    = ref[Int](0)
  val curY    = ref[Int](0)
  val curHP        = ref[Int](0)
  val curStrength = ref[Int](0)
  val curMagic     = ref[Int](0)
  val curDefense   = ref[Int](0)
  val curResistance= ref[Int](0)
  val curPrecision = ref[Int](0)
  val curAgility   = ref[Int](0)
  val curLuck      = ref[Int](0)
  val curMovement  = ref[Int](0)
  val curSymbol = ref[String]("")
  val curClass = ref[UnitClass](Soldier())

  val readingMap   = ref(false)
  val readingUnits = ref(false)
  val weapons = ref[List[Weapon]](Nil())
  val readingWeapons = ref(false)
  val readingWeapon  = ref(false)

  val wName   = ref[String]("")
  val wType   = ref[WeaponKind](Axe())
  val wDmg    = ref[DamageType](Physical())
  val wAtk    = ref[Int](0)
  val wHit    = ref[Int](0)
  val wUses   = ref[Int](0)
  val wCrit   = ref[Int](0)
  val wRange   = ref[(Int,Int)]((0,0))
  val lines = text.split("\n")

  lines.foreach { line =>
    val trimmed = line.trim()

    val mapOpen    = trimmed.indexOf("<map>")
    val mapClose   = trimmed.indexOf("</map>")
    val unitsOpen  = trimmed.indexOf("<units>")
    val unitsClose = trimmed.indexOf("</units>")

    if (mapOpen.isDefined())        readingMap.set(true)
    else if (mapClose.isDefined())  readingMap.set(false)
    else if (unitsOpen.isDefined()) readingUnits.set(true)
    else if (unitsClose.isDefined()) readingUnits.set(false)

    else if (readingMap.get()) {
      if (trimmed.length() > 0) {

        val tileText =
          trimmed.substring(0, trimmed.indexOf("/") match {
            case Some(idx) => idx
            case None()    => trimmed.length()
          })

        var row: List[Tile] = Nil()
        var i = 0
        val len = tileText.length()

        while (i < len) {
          val ch = tileText.substring(i, i + 1)

          if (ch == "f")      row = Cons(TileFloor(), row)
          else if (ch == "w") row = Cons(TileWall(), row)
          else if (ch == "t") row = Cons(TileForest(), row)
          else if (ch == "s") row = Cons(TileSand(), row)
          else if (ch == "h") row = Cons(TileHills(), row)
          else if (ch == "m") row = Cons(TileMarsh(), row)
          else {
            row = Cons(TileWall(), row)  //  fallback
          }


          i = i + 1
        }

        rows.set(Cons(reverse(row), rows.get()))
        height = height + 1
      }
    }

    else if (readingUnits.get()) {
      if (trimmed.indexOf("<weapons>") is Some(_))
  readingWeapons.set(true)

else if (trimmed.indexOf("</weapons>") is Some(_))
  readingWeapons.set(false)

else if (readingWeapons.get()) {

        if (trimmed.indexOf("<weapon>") is Some(_)) {
          readingWeapon.set(true)

          wName.set("")
          wType.set(Axe())
          wDmg.set(Physical())
          wAtk.set(0)
          wHit.set(0)
          wUses.set(0)
          wCrit.set(0)
          wRange.set((0,0))
        }

        else if (trimmed.indexOf("</weapon>") is Some(_)) {
          weapons.set(
            Cons(
              Weapon(
                wName.get(),
                wType.get(),
                wDmg.get(),
                wAtk.get(),
                wHit.get(),
                wUses.get(),
                wCrit.get(),
                wRange.get(),
                Nil()
              ),
              weapons.get()
            )
          )
          readingWeapon.set(false)
        }

        else if (readingWeapon.get()) {
          val n = between(trimmed, "<name>", "</name>")
          if (n.length() > 0) wName.set(n)

          val t = between(trimmed, "<type>", "</type>")
          if (t.length() > 0) wType.set(parseWeaponType(t))

          val d = between(trimmed, "<damage>", "</damage>")
          if (d.length() > 0) wDmg.set(parseDamageType(d))

          val atk = between(trimmed, "<attack>", "</attack>")
          if (atk.length() > 0) wAtk.set(ptoInt(atk))

          val hit = between(trimmed, "<hit>", "</hit>")
          if (hit.length() > 0) wHit.set(ptoInt(hit))

          val uses = between(trimmed, "<uses>", "</uses>")
          if (uses.length() > 0) wUses.set(ptoInt(uses))

          val crit = between(trimmed, "<crit>", "</crit>")
          if (crit.length() > 0) wCrit.set(ptoInt(crit))

           val range = between(trimmed, "<range>", "</range>")
          if (range.length() > 0) wRange.set(parseRange(range))
        }
      }
      if (trimmed.indexOf("<unit>") is Some(_)) {
        curSide.set("")
        curX.set(0)
        curY.set(0)
        curHP.set(0)
        curStrength.set(0)
        curMagic.set(0)
        curDefense.set(0)
        curResistance.set(0)
        curPrecision.set(0)
        curAgility.set(0)
        curLuck.set(0)
        curMovement.set(0)
        curSymbol.set("")
        curClass.set(Soldier())
        weapons.set(Nil())
      }

      else if (trimmed.indexOf("</unit>") is Some(_)) {
        val fx = curX.get() - 1
        val fy = curY.get() - 1
        readingWeapons.set(false)
        readingWeapon.set(false)

        val internalY = fy

         units.set(
          Cons(
             gameUnbit(
                  
              curSide.get(),
              fx,
              fy,

              curHP.get(),
              curStrength.get(),
              curMagic.get(),
              curDefense.get(),
              curResistance.get(),
              curPrecision.get(),
              curAgility.get(),
              curLuck.get(),
              curMovement.get(),
              reverse(weapons.get()),
              0,
              false,
              curSymbol.get(),
              curClass.get()
          )

,
            units.get()
          )
         )
      }


      else {
        
        val side = between(trimmed, "<side>", "</side>")
        if (side.length() > 0) curSide.set(side)

        val sym = between(trimmed, "<symbol>", "</symbol>")
        if (sym.length() > 0) curSymbol.set(sym)

        val xs = between(trimmed, "<x>", "</x>")
        if (xs.length() > 0) curX.set(ptoInt(xs))

        val ys = between(trimmed, "<y>", "</y>")
        if (ys.length() > 0) curY.set(ptoInt(ys))

        val hp = between(trimmed, "<hp>", "</hp>")
        if (hp.length() > 0) curHP.set(ptoInt(hp))

        val str = between(trimmed, "<strength>", "</strength>")
        if (str.length() > 0) curStrength.set(ptoInt(str))

        val mag = between(trimmed, "<magic>", "</magic>")
        if (mag.length() > 0) curMagic.set(ptoInt(mag))

        val deff = between(trimmed, "<defense>", "</defense>")
        if (deff.length() > 0) curDefense.set(ptoInt(deff))

        val res = between(trimmed, "<resistance>", "</resistance>")
        if (res.length() > 0) curResistance.set(ptoInt(res))

        val pre = between(trimmed, "<precision>", "</precision>")
        if (pre.length() > 0) curPrecision.set(ptoInt(pre))

        val agi = between(trimmed, "<agility>", "</agility>")
        if (agi.length() > 0) curAgility.set(ptoInt(agi))

        val luck = between(trimmed, "<luck>", "</luck>")
        if (luck.length() > 0) curLuck.set(ptoInt(luck))

        val mov = between(trimmed, "<movement>", "</movement>")
        if (mov.length() > 0) curMovement.set(ptoInt(mov))

        val cls = between(trimmed, "<class>", "</class>")
        if (cls.length() > 0) curClass.set(parseUnitClass( cls))
      }
    }
  }

  var mapRows : List[List[Tile]] = Nil()
  rows.get().foreach { r =>
    mapRows = Cons(r, mapRows)
  }

  var w = 0
  mapRows match {
    case Cons(firstRow, _) => w = firstRow.size()
    case Nil()             => w = 0
  }

  GameMap(w, height, mapRows, units.get())
}


