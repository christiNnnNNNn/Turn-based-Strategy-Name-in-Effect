module maploader

import string
import list
import src/model
import src/utils
import src/movement
import src/combat
effect ParseError(msg: String): Unit


def parseWeaponMod(s: String): WeaponMod =
  val t = s.trim()
  if (t == "none") NoneMod()
  else if (t == "armor_break") ArmorBreak(2) 
  else NoneMod()

def parseWeaponType(s: String): WeaponKind =
  if (s == "axe") Axe()
  else if (s == "sword") Sword()
  else if (s == "lance") Lance()
  else if (s == "bow") Bow()
  else Tome()

def parseDamageType(s: String): DamageType =
  if (s == "magic") Magic()
  else Physical()

def parseRange(s: String): (Int, Int) = {
  val comma = s.indexOf(",")
  comma match {
    case Some(i) =>
      val a = s.substring(0, i).trim()
      val b = s.substring(i + 1).trim()
      (ptoInt(a), ptoInt(b))
    case None() =>
      val x = ptoInt(s.trim())
      (x, x)
  }
}

def parseUnitClass(s: String): UnitClass =
  s.trim() match {
    case "soldier" => Soldier()
    case "armor"   => Armor()
    case "knight"  => Knight()
    case "flyer"   => Flyer()
    case _ =>

      Soldier()
  }

def isKnownTag(t: String): Bool =
  t == "map" || t == "/map" ||
  t == "units" || t == "/units" ||
  t == "unit" || t == "/unit" ||
  t == "weapons" || t == "/weapons" ||
  t == "weapon" || t == "/weapon" ||
  t == "modifier" || t == "/modifier" ||
  t == "modifiers" || t == "/modifiers"

def parseMap(text: String): GameMap / { ParseError } = {

  def dbgTop(stack: List[String]): String =
  stack match {
    case Cons(t, _) => t
    case Nil()      => "EMPTY"
  }
  
  val tagStack = ref[List[String]](Nil())
  val failed   = ref(false)
  val fallback = GameMap(0, 0, Nil(), Nil())

  def openTag(tagStack: Ref[List[String]], name: String): Unit =
    tagStack.set(Cons(name, tagStack.get()))

  def closeTag(tagStack: Ref[List[String]], name: String): Unit =
    tagStack.get() match {
      case Cons(top, rest) =>
        if (top != name) {
          failed.set(true)
          do ParseError("Closing tag </" ++ name ++ "> does not match <" ++ top ++ ">")
          ()
        } else {
          tagStack.set(rest)
        }

      case Nil() =>
        failed.set(true)
        do ParseError("Unexpected closing tag </" ++ name ++ ">")
        ()
    }

  def strInList(xs: List[String], s: String): Bool = xs match {
    case Nil() => false
    case Cons(h, t) => if (h == s) true else strInList(t, s)
  }

  def posEq(a: (Int, Int), b: (Int, Int)): Bool =
  a match {
    case (ax, ay) =>
      b match {
        case (bx, by) => (ax == bx) && (ay == by)
      }
  }

  def posInList(xs: List[(Int,Int)], p: (Int,Int)): Bool = xs match {
    case Nil() => false
    case Cons(h, t) =>
      if (posEq(h, p)) true else posInList(t, p)
  }

  def nthRow(rows: List[List[Tile]], y: Int): Option[List[Tile]] = {
    if (y < 0) None()
    else rows match {
      case Nil() => None()
      case Cons(r, rs) => if (y == 0) Some(r) else nthRow(rs, y - 1)
    }
  }

  def nthTile(row: List[Tile], x: Int): Option[Tile] = {
    if (x < 0) None()
    else row match {
      case Nil() => None()
      case Cons(t, ts) => if (x == 0) Some(t) else nthTile(ts, x - 1)
    }
  }

  def isWall(t: Tile): Bool = t match {
    case TileWall() => true
    case _          => false
  }
  
  var height = 0
  val rows   = ref[List[List[Tile]]](Nil())
  val units  = ref[List[gameUnbit]](Nil())

  val curSide = ref[String]("")
  val curX    = ref[Int](0)
  val curY    = ref[Int](0)
  val curHP        = ref[Int](0)
  val curStrength = ref[Int](0)
  val curMagic     = ref[Int](0)
  val curDefense   = ref[Int](0)
  val curResistance= ref[Int](0)
  val curPrecision = ref[Int](0)
  val curAgility   = ref[Int](0)
  val curLuck      = ref[Int](0)
  val curMovement  = ref[Int](0)
  val curSymbol = ref[String]("")
  val curClass = ref[UnitClass](Soldier())
  val readingMods = ref(false)
  val curMods     = ref[List[WeaponMod]](Nil())

  val readingMap   = ref(false)
  val readingUnits = ref(false)
  val weapons = ref[List[Weapon]](Nil())
  val readingWeapons = ref(false)
  val readingWeapon  = ref(false)

  val wName   = ref[String]("")
  val wType   = ref[WeaponKind](Axe())
  val wDmg    = ref[DamageType](Physical())
  val wAtk    = ref[Int](0)
  val wHit    = ref[Int](0)
  val wUses   = ref[Int](0)
  val wCrit   = ref[Int](0)
  val wRange   = ref[(Int,Int)]((0,0))
  val lines = text.split("\n")

  var builtTiles: List[List[Tile]] = Nil()
  var mapW: Int = 0
  var mapH: Int = 0

  val usedSymbols = ref[List[String]](Nil())
  val usedPos     = ref[List[(Int, Int)]](Nil())
  lines.foreach { line =>
    if (failed.get()) {
      ()
    } else {
      val cleanedLine =
        line.split("\r") match {
          case Cons(h, _) => h
          case Nil()      => ""
        }

      val trimmed = cleanedLine.trim()
      val mapRootOpen  = trimmed == "<Map>"
      val mapRootClose = trimmed == "</Map>"
      val mapOpen    = trimmed == "<map>"
      val mapClose   = trimmed == "</map>"
      val unitsOpen  = trimmed == "<units>"
      val unitsClose = trimmed == "</units>"
      val isWeaponsOpen  = trimmed == "<weapons>"
      val isWeaponsClose = trimmed == "</weapons>"
      val isWeaponOpen   = trimmed == "<weapon>"
      val isWeaponClose  = trimmed == "</weapon>"
      if (mapRootOpen) openTag(tagStack, "Map")
      else if (mapRootClose) closeTag(tagStack, "Map")
      else if (mapOpen) {
        if (readingUnits.get()) {
          failed.set(true)
          do ParseError("<map> opened inside <units>")
          ()
        }
        readingMap.set(true)
        openTag(tagStack, "map")
      }
      else if (mapClose) {
         if (not(readingMap.get())) {
            failed.set(true)
            do ParseError("</map> without <map>")
            ()
          }
          readingMap.set(false)
          closeTag(tagStack, "map")
           
          builtTiles = reverse(rows.get())
          mapH = height
          builtTiles match {
            case Cons(firstRow, _) => mapW = firstRow.size()
            case Nil()             => mapW = 0
          }
              }
      else if (unitsOpen) {
        if (readingMap.get()) {
          failed.set(true)
          do ParseError("<units> opened inside <map>")
          ()
        }
        readingUnits.set(true)
        openTag(tagStack, "units")
      }
      else if (unitsClose) {
        if (not(readingUnits.get())) {
          failed.set(true)
          do ParseError("</units> without <units>")
          ()
        }
        readingUnits.set(false)
        closeTag(tagStack, "units")
      }
      else if (readingMap.get()) {
        if (trimmed.indexOf("/") is Some(_)) {
        if (trimmed.length() > 0) {

          val tileText =
            trimmed.substring(0, trimmed.indexOf("/") match {
              case Some(idx) => idx
              case None()    => trimmed.length()
            })

          var row: List[Tile] = Nil()
          var i = 0
          val len = tileText.length()

          while (i < len) {
            val ch = tileText.substring(i, i + 1)

            if (ch == "f")      row = Cons(TileFloor(), row)
            else if (ch == "w") row = Cons(TileWall(), row)
            else if (ch == "t") row = Cons(TileForest(), row)
            else if (ch == "s") row = Cons(TileSand(), row)
            else if (ch == "h") row = Cons(TileHills(), row)
            else if (ch == "m") row = Cons(TileMarsh(), row)
            else {
              row = Cons(TileFloor(), row)  //  fallback
            }

            i = i + 1
          }

          rows.set(Cons(reverse(row), rows.get()))
          height = height + 1
        }
         } else if (trimmed.length() > 0) {
          failed.set(true)
          do ParseError("Non-map row inside <map>: " ++ trimmed)
          ()
        }
      }

      else if (readingUnits.get()) {
        
        if (trimmed == "<unit>") {
          printString("[DBG] SAW UNIT OPEN LINE: " ++ trimmed ++ "\n")
          printString("[DBG] <unit> open, top before = " ++ dbgTop(tagStack.get()) ++ "\n")
          openTag(tagStack, "unit")
          printString("[DBG] <unit> open, top after  = " ++ dbgTop(tagStack.get()) ++ "\n")

          curSide.set("player")
          curX.set(0); curY.set(0)
          curHP.set(1); curStrength.set(1); curMagic.set(1)
          curDefense.set(1); curResistance.set(1)
          curPrecision.set(1); curAgility.set(1); curLuck.set(1)
          curMovement.set(1)
          curSymbol.set("")
          curClass.set(Soldier())

          weapons.set(Nil())
          readingWeapons.set(false)
          readingWeapon.set(false)
          readingMods.set(false)
          curMods.set(Nil())
        }
       else if (trimmed == "</unit>") {
          printString("[DBG] </unit> close, top before = " ++ dbgTop(tagStack.get()) ++ "\n")
          closeTag(tagStack, "unit")
          printString("[DBG] </unit> close, top after  = " ++ dbgTop(tagStack.get()) ++ "\n")

          val fx = curX.get() - 1
          val fy = curY.get() - 1

          val mw = mapW
          val mh = mapH

          if (fx < 0 || fy < 0 || fx >= mw || fy >= mh) {
            failed.set(true)
            do ParseError(
              "Unit '" ++ curSymbol.get() ++ "' placed outside map at (" ++
              show(fx + 1) ++ "," ++ show(fy + 1) ++ "), map is " ++
              show(mw) ++ "x" ++ show(mh)
            )
            ()
          }
          else if (posInList(usedPos.get(), (fx, fy))) {

            failed.set(true)
            do ParseError(
              "Unit '" ++ curSymbol.get() ++ "' placed on occupied tile (" ++
              show(fx + 1) ++ "," ++ show(fy + 1) ++ ")"
            )
            ()
          }
          else if (strInList(usedSymbols.get(), curSymbol.get())) {

            failed.set(true)
            do ParseError(
              "Duplicate unit symbol '" ++ curSymbol.get() ++ "'"
            )
            ()
          }
          else {
 
            val tempMap = GameMap(mapW, mapH, builtTiles, Nil())
            val t = tileAt(tempMap, fx, fy)
            if (isWall(t) && not(isFlyer(curClass.get()))) {
                  failed.set(true)
                  do ParseError(
                    "non Fyling Unit '" ++ curSymbol.get() ++ "' placed on a wall at (" ++
                    show(fx + 1) ++ "," ++ show(fy + 1) ++ ")"
                  )
                  ()
                }
              }

            if (not(failed.get())) {
              usedPos.set(Cons((fx, fy), usedPos.get()))
              usedSymbols.set(Cons(curSymbol.get(), usedSymbols.get()))

              units.set(
                Cons(
                  gameUnbit(
                    curSide.get(),
                    fx, fy,
                    curHP.get(),
                    curStrength.get(),
                    curMagic.get(),
                    curDefense.get(),
                    curResistance.get(),
                    curPrecision.get(),
                    curAgility.get(),
                    curLuck.get(),
                    curMovement.get(),
                    reverse(weapons.get()),
                    0,
                    false,
                    curSymbol.get(),
                    curClass.get()
                  ),
                  units.get()
                )
              )
            
          }

          readingWeapons.set(false)
          readingWeapon.set(false)
          readingMods.set(false)
        }

        else if (trimmed == "<weapons>"){
          readingWeapons.set(true)
          openTag(tagStack, "weapons")
        }

        else if (trimmed == "</weapons>") {
          if (not(readingWeapons.get())) {
            failed.set(true)
            do ParseError("</weapons> without <weapons>")
            ()
          }
          readingWeapons.set(false)
          closeTag(tagStack, "weapons")
        }

        else if (trimmed == "<weapon>") {
          if (not(readingWeapons.get())) {
            failed.set(true)
            do ParseError("<weapon> outside <weapons>")
            ()
          } else {
            readingWeapon.set(true)
            openTag(tagStack, "weapon")

            wName.set("No_Name_Set")
            wType.set(Axe())
            wDmg.set(Physical())
            wAtk.set(1)
            wHit.set(1)
            wUses.set(1)
            wCrit.set(1)
            wRange.set((1,1))
            readingMods.set(false)
            curMods.set(Nil())
          }
        }


        else if (trimmed == "</weapon>") {
          if (not(readingWeapon.get())) {
            failed.set(true)
            do ParseError("</weapon> without <weapon>")
            ()
          } else {
            readingWeapon.set(false)
            closeTag(tagStack, "weapon")

          weapons.set(
            Cons(
              Weapon(
                wName.get(),
                wType.get(),
                wDmg.get(),
                wAtk.get(),
                wHit.get(),
                wUses.get(),
                wCrit.get(),
                wRange.get(),
                reverse(curMods.get())
              ),
              weapons.get()
            )
          )
          }
        }

        else if (readingWeapon.get()) {
          val n = between(trimmed, "<name>", "</name>")
          if (n.length() > 0) wName.set(n)

          val t = between(trimmed, "<kind>", "</kind>")
          if (t.length() > 0) wType.set(parseWeaponType(t))

          val d = between(trimmed, "<damageType>", "</damageType>")
          if (d.length() > 0) wDmg.set(parseDamageType(d))

          val atk = between(trimmed, "<attack>", "</attack>")
          if (atk.length() > 0) wAtk.set(ptoInt(atk))

          val hit = between(trimmed, "<hit>", "</hit>")
          if (hit.length() > 0) wHit.set(ptoInt(hit))

          val uses = between(trimmed, "<uses>", "</uses>")
          if (uses.length() > 0) wUses.set(ptoInt(uses))

          val crit = between(trimmed, "<crit>", "</crit>")
          if (crit.length() > 0) wCrit.set(ptoInt(crit))

          val range = between(trimmed, "<range>", "</range>")
          if (range.length() > 0) wRange.set(parseRange(range))

          if (trimmed == "<modifiers>") {
            readingMods.set(true)
          } else if (trimmed == "</modifiers>") {
            readingMods.set(false)
          } else if (readingMods.get()) {
            val m = between(trimmed, "<modifier>", "</modifier>")
            if (m.length() > 0) curMods.set(Cons(parseWeaponMod(m), curMods.get()))
          }
        }

        // ----- unit fields -----
        else {
          val side = between(trimmed, "<side>", "</side>")
          if (side.length() > 0) curSide.set(side)

          val sym = between(trimmed, "<symbol>", "</symbol>")
          if (sym.length() > 0) curSymbol.set(sym)

          val xs = between(trimmed, "<x>", "</x>")
          if (xs.length() > 0) curX.set(ptoInt(xs))

          val ys = between(trimmed, "<y>", "</y>")
          if (ys.length() > 0) curY.set(ptoInt(ys))

          val hp = between(trimmed, "<hp>", "</hp>")
          if (hp.length() > 0) curHP.set(ptoInt(hp))

          val str = between(trimmed, "<strength>", "</strength>")
          if (str.length() > 0) curStrength.set(ptoInt(str))

          val mag = between(trimmed, "<magic>", "</magic>")
          if (mag.length() > 0) curMagic.set(ptoInt(mag))

          val deff = between(trimmed, "<defense>", "</defense>")
          if (deff.length() > 0) curDefense.set(ptoInt(deff))

          val res = between(trimmed, "<resistance>", "</resistance>")
          if (res.length() > 0) curResistance.set(ptoInt(res))

          val pre = between(trimmed, "<precision>", "</precision>")
          if (pre.length() > 0) curPrecision.set(ptoInt(pre))

          val agi = between(trimmed, "<agility>", "</agility>")
          if (agi.length() > 0) curAgility.set(ptoInt(agi))

          val luck = between(trimmed, "<luck>", "</luck>")
          if (luck.length() > 0) curLuck.set(ptoInt(luck))

          val mov = between(trimmed, "<movement>", "</movement>")
          if (mov.length() > 0) curMovement.set(ptoInt(mov))

          val cls = between(trimmed, "<class>", "</class>")
          if (cls.length() > 0) curClass.set(parseUnitClass(cls))
        }
      }
    }
  }
         var mapRows : List[List[Tile]] = Nil()
       rows.get().foreach { r =>
  mapRows = Cons(r, mapRows)
}
 
  var w = 0
  mapRows match {
    case Cons(firstRow, _) => w = firstRow.size()
    case Nil()             => w = 0
  }
 if (not(failed.get())) {
  tagStack.get() match {
    case Nil() => ()
    case Cons(t, _) =>
      failed.set(true)
      do ParseError("Unclosed tag <" ++ t ++ "> at end of file")
  }
  }
  if (failed.get()) fallback
  else GameMap(w, height, mapRows, units.get())
  

}
