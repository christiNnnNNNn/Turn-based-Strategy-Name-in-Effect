
import src/model
effect canEnter(x: Int, y: Int): Bool
effect moveCost(x: Int, y: Int): Int
effect isOccupied(x: Int, y: Int): Bool
record TilePos(x: Int, y: Int)
record Reach(
  x: Int,
  y: Int,
  remaining: Int
)

def listGet[A](xs: List[A], i: Int): Option[A] =
  if (i < 0) None()
  else xs match {
    case Nil() => None()
    case Cons(x, rest) =>
      if (i == 0) Some(x)
      else listGet(rest, i - 1)
  }

//get a tile
def tileAt(map: GameMap, x: Int, y: Int): Tile =
  listGet(map.tiles, y) match {
    case None() =>
      TileWall()

    case Some(row) =>
      listGet(row, x) match {
        case None() => TileWall()
        case Some(t) => t
      }
  }

def classMoveMode(c: UnitClass): MoveMode =
  c match {
    case Soldier() => Foot()
    case Armor()   => Heavy()
    case Knight()  => Cavalry()
    case Flyer()   => Flying()
  }

def terrainCost(t: Tile): Int =
  t match {
    case TileFloor()  => 1
    case TileSand()   => 2
    case TileHills()  => 2
    case TileForest() => 3
    case TileMarsh()  => 3
    case TileWall()   => 999
  }

def terrainPassableForFoot(t: Tile): Bool =
  t match {
    case TileWall() => false
    case _          => true
  }
 
// resolves if a unit can enter a tile
def tryMove(
  x: Int,
  y: Int,
  remaining: Int
): Int / { canEnter, moveCost } = {
  if (do canEnter(x, y)) {
    remaining - do moveCost(x, y)
  } else {
    remaining
  }
}

// can a tile be enteres
def isReachable(x: Int, y: Int, rs: List[TilePos]): Bool =
  rs match {
    case Nil() => false
    case Cons(p, rest) =>
      if (p.x == x && p.y == y) true
      else isReachable(x, y, rest)
  }

//for clating optimal paht sof movment
def betterSeen(
  seen: List[(TilePos, Int)],
  x: Int,
  y: Int,
  remaining: Int
): Bool =
  seen match {
    case Nil() => false
    case Cons((TilePos(px, py), r), rest) =>
      if (px == x && py == y && r >= remaining)
        true
      else
        betterSeen(rest, x, y, remaining)
  }

//for the movment algorithm
def updateSeen(
  seen: List[(TilePos, Int)],
  x: Int,
  y: Int,
  remaining: Int
): List[(TilePos, Int)] =
  seen match {
    case Nil() =>
      Cons((TilePos(x, y), remaining), Nil())

    case Cons((TilePos(px, py), r), rest) =>
      if (px == x && py == y) {
        if (remaining > r)
          Cons((TilePos(x, y), remaining), rest)
        else
          seen
      } else
        Cons((TilePos(px, py), r), updateSeen(rest, x, y, remaining))
  }

//neigboring tiles of a unit for the alÃ¶gorithm
def neighbors(r: Reach): List[Reach] =
  Cons(Reach(r.x + 1, r.y, r.remaining),
  Cons(Reach(r.x - 1, r.y, r.remaining),
  Cons(Reach(r.x, r.y + 1, r.remaining),
  Cons(Reach(r.x, r.y - 1, r.remaining),
       Nil()))))

// reslves the core algorithm for displaying possible movment
def expand(
  frontier: List[Reach],
  seen: List[(TilePos, Int)],
  reachable: List[TilePos]
): List[TilePos] / { canEnter, moveCost } =

  frontier match {

    case Nil() =>
      reachable

    case Cons(r, rest) => {

      if (r.remaining < 0) {
        expand(rest, seen, reachable)

      } else {
        if (not (do canEnter(r.x, r.y))){
          expand(rest, seen, reachable)

        } else {
          if (betterSeen(seen, r.x, r.y, r.remaining)) {
            expand(rest, seen, reachable)

          } else {
            val c = do moveCost(r.x, r.y)
            val nextRemaining = r.remaining - c
            val reachable2 =
              if (nextRemaining >= 0) Cons(TilePos(r.x, r.y), reachable)
              else reachable
            val newSeen =
              updateSeen(seen, r.x, r.y, r.remaining)

            val newFrontier =
              if (nextRemaining >= 0) {
                append(rest, neighbors(Reach(r.x, r.y, nextRemaining)))
              }else
                rest

            expand(
              newFrontier,
              newSeen,
              Cons(TilePos(r.x, r.y), reachable2)
            )
          }
        }
      }
    }
  }

//handler for class movment rules
def withUnitMovementRules[R](
  map: GameMap,
  u: gameUnbit,
  startX: Int,
  startY: Int
) { program: () => R / { canEnter, moveCost } } : R =
  try { program() }
  with canEnter { (x, y) =>
    val inBounds =
      x >= 0 && y >= 0 && x < map.width && y < map.height

    val occupied =
      unitAt(map.units, x, y).isDefined() &&
      not(x == startX && y == startY)

    if (not(inBounds) || occupied) resume(false)
    else {
      val tile = tileAt(map, x, y)
      classMoveMode(u.class) match {

        case Flying() =>

          resume(tile match {  case _ => true })

        case Foot() =>
          resume(terrainPassableForFoot(tile))

        case Cavalry() =>

          resume(tile match {
            case TileWall()   => false
            case _            => true
          })

        case Heavy() =>

          resume(tile match {
            case TileWall()  => false
            case _           => true
          })
      }
    }
  }
  with moveCost { (x, y) =>
    val tile = tileAt(map, x, y)
    classMoveMode(u.class) match {

      case Flying() =>
        resume(1)

      case Heavy() =>
        val base = terrainCost(tile)
        if (base >= 999) resume(999) else resume(base + 1)

      case Cavalry() =>
        resume(tile match {
          case TileFloor() => 1
          case TileSand()  => 3
          case TileHills() => 3
          case TileForest() => 4
          case TileMarsh()  => 4
          case TileWall()   => 999
        })

      case Foot() =>
        resume(terrainCost(tile))
    }
  }

def withGroundMovement(map: GameMap, u: gameUnbit): List[TilePos] =
  withUnitMovementRules(map, u, u.x, u.y) {
    reachableTiles(u.x, u.y, u.movement)
  }

//gives back a unit at a certain position
def unitAt(
  units: List[gameUnbit],
  x: Int,
  y: Int
): Option[gameUnbit] =
  units match {
    case Nil() =>
      None()

    case Cons(u, rest) =>
      if (u.x == x && u.y == y)
        Some(u)
      else
        unitAt(rest, x, y)
  }

//for displaying possible movment
def reachableTiles(
  x: Int,
  y: Int,
  movement: Int
): List[TilePos] / { canEnter, moveCost } =
  expand(
    Cons(Reach(x, y, movement), Nil()),
    Nil(),
    Nil()
  )
//mahtten distance for the movment algorithm
def manhattan(x1: Int, y1: Int, x2: Int, y2: Int): Int =
  abs(x1 - x2) + abs(y1 - y2)
