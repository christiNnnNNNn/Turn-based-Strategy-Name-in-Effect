module menu

import src/maploader
import src/model
import src/movement
import src/renderer
import src/combat
import src/gamestate
import src/utils
import src/weaponhandling
import string

def afterPlayerCombat(m: GameMap): Unit =
 
  endOrContinue(m) { mm =>
    runMenu(mm, None(), Nil(), None(), None())
  }

def runMenu(
  map: GameMap,
  selected: Option[gameUnbit],
  reachable: List[TilePos],
  moveState: Option[MoveState],
  combatState: Option[CombatState]
): Unit = {

 def parseInput(line: String, combatState: Option[CombatState], moveState: Option[MoveState]): UIAction = {
  val trimmed = line.trim()

  combatState match {
 
    case Some(_) =>
      if (trimmed == "f") ConfirmCombat()
      else if (trimmed == "g") CancelCombat()
      else CancelCombat()

   
    case None() =>
      if (trimmed == "q") Quit()
      else if (trimmed == "m") ShowMovement()
      else if (trimmed == "w") MoveCursor(0, -1)
      else if (trimmed == "s") MoveCursor(0, 1)
      else if (trimmed == "a") MoveCursor(-1, 0)
      else if (trimmed == "d") MoveCursor(1, 0)
      else if (trimmed == "r") ConfirmMove()
      else if (trimmed == "t") ListTargets()

    
      else if (trimmed == "x") EndTurn()

      
      else if (trimmed == "c") CancelMove()

      else {
        val toks = dropEmpty(split(trimmed, " "))

        toks match {
          case Cons("s", Cons(sym, Nil())) =>
            val s = sym.trim()
            if (s.length() == 0) ShowMovement()
            else {
              unitBySymbol(map.units, s) match {

                case Some(u) =>
                  
                  SelectUnit(u.x, u.y)

                case None() =>
                  ShowMovement()
              }
  }


          case Cons(n, Nil()) =>
            parseIntOpt(n) match {
              case Some(i) => SwitchWeapon(i - 1)
              case None()  => ShowMovement()
            }

          case _ =>
            ShowMovement()
        }
      }
  }
}

  val buffer = ref(makeBuffer(map.width, map.height))
  
  withConsole(buffer, map, selected, reachable, moveState)
  selected match {
  case Some(u) =>
    printUnitStats(u)
    printWeapons(u)
  case None() =>
    printString("\n(No unit selected)\n")
}
  moveState match {
  case Some(Moving(_, _, _, _, _, rem)) =>
    printString("\nRemaining movement: " ++ rem.show ++ "\n")
  case None() => ()
}
  printBuffer(buffer.get())

  val c = newConsole()
  val line = readLine(c)
  closeConsole(c)
  dbg("readLine returned: '" ++ line ++ "'")
  dbg("dispatch action")
  val action = parseInput(line,combatState, moveState)
  action match {
    case Quit() =>
      printString("Bye!\n")
      ()
    case SelectUnit(x, y) =>
      dbg("SelectUnit(" ++ x.show ++ "," ++ y.show ++ ")")

      val selOpt = unitAt(map.units, x, y)

      dbg(
        "SelectUnit result: " ++
        (selOpt match {
          case Some(_) => "Some(unit)"
          case None()  => "None"
        })
      )
      val newSelected =
      selOpt match {
        case Some(u) =>
          if (u.side == "player" && u.moved) {
            printString("That unit already moved this turn.\n")
            None()
          } else Some(u)
        case None() =>
          None()
      }
      
      runMenu(
        map,
        newSelected,
        Nil(),        
        None(),
        None()       
      )
   case MoveCursor(dx, dy) =>
    moveState match {
      case Some(Moving(u, sx, sy, cx, cy, rem)) =>
        val nx = cx + dx
        val ny = cy + dy

        val newRem =
          withUnitMovementRules(map, u, u.x, u.y) {
            tryMove(nx, ny, rem)
          }

        val nextState =
          if (newRem >= 0 && newRem < rem)
            Some(Moving(u, sx, sy, nx, ny, newRem))
          else
            moveState

        runMenu(map, selected, reachable, nextState,None())
      case None() =>
        runMenu(map, selected, reachable, None(),None())
    }


  case CancelMove() =>
    runMenu(map, selected, reachable, None(), None())
    case ConfirmMove() =>    
    printString("[DBG] ConfirmMove pressed\n")     
      moveState match {
        case Some(Moving(u, sx, sy, cx, cy, _)) =>
          printString(
          "[DBG] Commit cursor at (" ++ cx.show ++ "," ++ cy.show ++ ")\n"
        )
          val moved =
            gameUnbit(
              u.side,
              cx, cy,
              u.hp,
              u.strength,
              u.magic,
              u.defense,
              u.resistance,
              u.precision,
              u.agility,
              u.luck,
              u.movement,
              u.weapons,
              u.activeWeapon,
              true,
              u.symbol,
              u.class
            )
          printString(
    "[DBG] New unit position = (" ++ moved.x.show ++ "," ++ moved.y.show ++ ")\n"
  )
          val newUnits =
          replaceUnit(map.units, sx, sy, moved)

        val newMap =
          GameMap(map.width, map.height, map.tiles, newUnits)
          map.units.foreach { u =>
    printString(
      "[DBG] render unit at (" ++ u.x.show ++ "," ++ u.y.show ++ ")\n"
    )
  }

        runMenu(newMap, Some(moved), Nil(), None(), None())

        case None() =>
          runMenu(map, selected, reachable, None(), None())
      }

   
  case ShowMovement() =>
      val newReachable =
        selected match {
          case Some(u) =>
            withGroundMovement(map, u)
          case None() =>
            Nil()
        }

      val newMoveState =
        selected match {
          case Some(u) =>
            if (u.side == "player")
              Some(Moving(u, u.x, u.y, u.x, u.y, u.movement))
            else
              None()   
          case None() =>
            None()
        }

      runMenu(
        map,
        selected,
        newReachable,
        newMoveState,
        None()
      )
    case SwitchWeapon(i) =>
  selected match {
    case Some(u) =>
      val updated = switchWeapon(u, i)

      
      val newUnits = replaceUnit(map.units, u.x, u.y, updated)

      val newMap =
        GameMap(map.width, map.height, map.tiles, newUnits)

      runMenu(newMap, Some(updated), reachable, moveState, None())

    case None() =>
      runMenu(map, selected, reachable, moveState, None())
  }
  case ListTargets() =>
    selected match {
      case Some(att) =>
      if (att.side != "player") {
          printString("You can only attack with player units.\n")
          runMenu(map, selected, reachable, moveState, combatState)
        } else {
        weaponhandling::activeWeapon(att) match {
          case Some(wAtt) =>
            val (attX, attY) =
            moveState match {
              case Some(Moving(_, _, _, cx, cy, _)) => (cx, cy)
              case None()                           => (att.x, att.y)
            }

          val ts = collectTargets(att, attX, attY, map.units, wAtt)

          if (ts is Nil()) {
            printString("No targets in range.\n")
            runMenu(map, selected, reachable, moveState,None())
          } else {
            printString("\n=== TARGETS (press number) ===\n")
            printTargets(ts, 1)

            val c2 = newConsole()
            val line2 = readLine(c2)
            closeConsole(c2)


              val idxOpt = parseIntOpt(line2.trim())
              idxOpt match {
                case Some(k) =>
                  val idx0 = k - 1
                  val defOpt = listGet(ts, idx0)   
                  defOpt match {
                    case Some(target) =>
                      weaponhandling::activeWeapon(target) match {
                        case Some(wDef) =>

                        
                          val (sx, sy) =
                            moveState match {
                              case Some(Moving(_, sx0, sy0, _, _, _)) => (sx0, sy0)
                              case None() => (att.x, att.y)
                            }

                          val (ax, ay) =
                            moveState match {
                              case Some(Moving(_, _, _, cx, cy, _)) => (cx, cy)
                              case None() => (att.x, att.y)
                            }

                          
                          val attAtCursor =
                            gameUnbit(
                              att.side,
                              ax, ay,
                              att.hp,
                              att.strength, att.magic, att.defense, att.resistance,
                              att.precision, att.agility, att.luck,
                              att.movement,
                              att.weapons,
                              att.activeWeapon,
                              att.moved,
                              att.symbol,
                              att.class
                            )

                          val p = previewPure(map, attAtCursor, target, wAtt, wDef)


                          val cs =
                            CombatState(attAtCursor, sx, sy, ax, ay, target, wAtt, wDef, p)

                          printPreview(cs)
                          runMenu(map, selected, reachable, moveState, Some(cs))

                        case None() =>
                          printString("Defender has no weapon.\n")
                          runMenu(map, selected, reachable, moveState, combatState)
                      }

                      
                    case None() =>
                      printString("Invalid target.\n")
                      runMenu(map, selected, reachable, moveState, None())
                  }

                case None() =>
                  printString("Invalid number.\n")
                  runMenu(map, selected, reachable, moveState, None())
              }
            }

          case None() =>
            printString("No active weapon.\n")
            runMenu(map, selected, reachable, moveState, None())
        }
        }
      case None() =>
        printString("No unit selected.\n")
        runMenu(map, selected, reachable, moveState, None())
    }
  case CancelCombat() =>
    runMenu(map, selected, reachable, moveState, None())

case ConfirmCombat() =>
  try {
    combatState match {
      case None() =>
        runMenu(map, selected, reachable, moveState, None())

      case Some(cs) =>
        
        val att0 = decWeaponUse(cs.attacker)
        val att0AtCursor =
          gameUnbit(
            att0.side,
            cs.attackerX, cs.attackerY,
            att0.hp,
            att0.strength, att0.magic, att0.defense, att0.resistance,
            att0.precision, att0.agility, att0.luck,
            att0.movement,
            att0.weapons,
            att0.activeWeapon,
            true,
            att0.symbol,
            att0.class
          )
        val def0 = cs.defender

        weaponhandling::activeWeapon(att0) match {
          case None() =>
            runMenu(map, selected, reachable, None(), None())

          case Some(wAttNow) =>
            weaponhandling::activeWeapon(def0) match {
              case None() =>
                runMenu(map, selected, reachable, None(), None())

              case Some(wDefNow) =>
                val pAtt = previewPure(map, att0, def0, wAttNow, wDefNow)
                val r1   = resolveAttack(att0, def0, pAtt)
                val def1 = applyDamage(def0, r1.damage)

                printString(
                  "\nATTACKER: " ++
                  (if (r1.hit) "HIT" else "MISS") ++
                  (if (r1.crit) " (CRIT)" else "") ++
                  " dmg=" ++ r1.damage.show ++ "\n"
                )

                val unitsA =
                  replaceUnit(map.units, cs.attackerStartX, cs.attackerStartY, att0AtCursor)

                
                val units1 =
                  replaceUnit(unitsA, def0.x, def0.y, def1)

                val map1 =
                  GameMap(map.width, map.height, map.tiles, units1)

                if (not(alive(def1))) {
                  printString("Defender defeated.\n")
                  endOrContinue(map1) { mClean =>
                    afterPlayerCombat(mClean)
                  }
                } else {
                  

                  if (canCounter(def1, att0, wDefNow)) {
                    val pDef = previewPure(map1, def1, att0, wDefNow, wAttNow)
                    val r2   = resolveAttack(def1, att0, pDef)
                    val att1 = applyDamage(att0, r2.damage)

                    printString(
                      "DEFENDER: " ++
                      (if (r2.hit) "HIT" else "MISS") ++
                      (if (r2.crit) " (CRIT)" else "") ++
                      " dmg=" ++ r2.damage.show ++ "\n"
                    )

                    val units2 =
                      replaceUnit(map1.units, cs.attackerX, cs.attackerY, att1)

                    val map2   = GameMap(map1.width, map1.height, map1.tiles, units2)

                    endOrContinue(map2) { mClean =>
                      afterPlayerCombat(mClean)
                    }

                  } else {
                    printString("No counterattack.\n")
                    endOrContinue(map1) { mClean =>
                      afterPlayerCombat(mClean)
                    }

                  }
                }
            }
        }
    }
  } with roll { max =>
  val m: Int = if (max <= 0) 1 else max
  val r: Int = randInt(m)   
  resume(r)
}
case EndTurn() =>
  printString("\n--- Enemy Phase ---\n")

  val afterEnemy = enemyPhase(map)

  endOrContinue(afterEnemy) { mAlive =>
    // start of new player turn: reset player moved flags
    val resetUnits = resetMoved(mAlive.units)
    val nextMap = GameMap(mAlive.width, mAlive.height, mAlive.tiles, resetUnits)

    printString("\n--- Player Turn ---\n")
    runMenu(nextMap, None(), Nil(), None(), None())
  }
  }
}
