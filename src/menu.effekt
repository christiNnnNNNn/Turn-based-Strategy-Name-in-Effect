module menu

import src/maploader
import src/model
import src/movement
import src/renderer
import src/combat
import string


extern type JSConsole






extern def readFile(path: String) at io: String =
  jsNode """
    require('fs').readFileSync(${path}, 'utf8')
  """

extern def printString(s: String) at io: Unit =
  jsNode "process.stdout.write(${s})"

extern def readLine(console: JSConsole) at async: String =
    jsNode "$effekt.capture(k => ${console}.once('line', k))"
extern def newConsole() at io: JSConsole =
    jsNode """readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })"""
extern def closeConsole(c: JSConsole) at io: Unit =
  jsNode "${c}.close()"

type UIAction {
  Quit()
  SelectUnit(x: Int, y: Int)
  ShowMovement()
  SwitchWeapon(index: Int)
  MoveCursor(dx: Int, dy: Int)
  CancelMove()
  ConfirmMove() 
  ListTargets()       
  ConfirmCombat()     
  CancelCombat()       
  }

record CombatState(
  attacker: gameUnbit,
  attackerStartX: Int,
  attackerStartY: Int,
  attackerX: Int,
  attackerY: Int,
  defender: gameUnbit,
  wAtt: Weapon,
  wDef: Weapon,
  preview: CombatPreview
)








def unitAtPos(
  units: List[gameUnbit],
  x: Int,
  y: Int
): Option[gameUnbit] =
  units match {
    case Nil() => None()
    case Cons(u, rest) =>
      if (u.x == x && u.y == y) Some(u)
      else unitAtPos(rest, x, y)
  }
def tileAt(
  tiles: List[List[Tile]],
  x: Int,
  y: Int
): Tile =
  tiles match {
    case Nil() =>
      TileWall()   

    case Cons(row, rest) =>
      if (y == 0) tileAtRow(row, x)
      else tileAt(rest, x, y - 1)
  }

def tileAtRow(row: List[Tile], x: Int): Tile =
  row match {
    case Nil() =>
      TileWall()

    case Cons(t, rest) =>
      if (x == 0) t
      else tileAtRow(rest, x - 1)
  }
def printPreview(cs: CombatState): Unit =
  printString(
    "\n=== COMBAT PREVIEW ===\n" ++
    "Target at (" ++ (cs.defender.x + 1).show ++ "," ++ (cs.defender.y + 1).show ++ ")\n" ++
    "DAMAGE = " ++ cs.preview.dmg.show ++ "\n" ++
    "HIT%   = " ++ cs.preview.hit.show ++ "\n" ++
    "CRIT%  = " ++ cs.preview.crit.show ++ "\n" ++
    "Confirm: f   Cancel: g\n"
   )
def switchWeapon(
  u: gameUnbit,
  newIndex: Int
): gameUnbit = {

  def weaponCount(ws: List[Weapon]): Int =
    ws match {
      case Nil() => 0
      case Cons(_, rest) => 1 + weaponCount(rest)
    }

  val count = weaponCount(u.weapons)

  if (
    u.side == "player" &&
    newIndex >= 0 &&
    newIndex < count
  )
    gameUnbit(
      u.side,
      u.x,
      u.y,
      u.hp,
      u.strength,
      u.magic,
      u.defense,
      u.resistance,
      u.precision,
      u.agility,
      u.luck,
      u.movement,
      u.weapons,
      newIndex       
    )
  else
    u
}
def replaceUnit(
  units: List[gameUnbit],
  oldX: Int,
  oldY: Int,
  updated: gameUnbit
): List[gameUnbit] =
  units match {
    case Nil() => Nil()

    case Cons(u, rest) =>
      if (u.x == oldX && u.y == oldY)
        Cons(updated, rest)
      else
        Cons(u, replaceUnit(rest, oldX, oldY, updated))
  }

def parseWeaponIndex(line: String): Option[Int] =
  try {
    Some(line.toInt1)
  } with Exception[WrongFormat] {
    def raise(_, _) = None()
  }

def parseIntOpt(s: String): Option[Int] =
  try {
    Some(s.toInt)
  } with Exception[WrongFormat] {
    def raise(_, _) = None()
  }


def setWeaponAt(ws: List[Weapon], i: Int, nw: Weapon): List[Weapon] =
  ws match {
    case Nil() => Nil()
    case Cons(w, rest) =>
      if (i == 0) Cons(nw, rest)
      else Cons(w, setWeaponAt(rest, i - 1, nw))
  }
def effectivePosition(
  selected: Option[gameUnbit],
  moveState: Option[MoveState]
): Option[(gameUnbit, Int, Int)] =
  moveState match {
    case Some(Moving(u, _, _, cx, cy, _)) =>
      Some((u, cx, cy))
    case None() =>
      selected match {
        case Some(u) => Some((u, u.x, u.y))
        case None()  => None()
      }
  }
def activeWeapon(u: gameUnbit): Option[Weapon] =
  getWeaponAt(u.weapons, u.activeWeapon)

def decWeaponUse(u: gameUnbit): gameUnbit =
  activeWeapon(u) match {
    case None() => u
    case Some(w) =>
      val newUses = max(0, w.uses - 1)
      val w2 = Weapon(w.name, w.kind, w.damageType, w.attack, w.hit, newUses, w.crit,w.range, w.mods)
      val ws2 = setWeaponAt(u.weapons, u.activeWeapon, w2)
      gameUnbit(
        u.side, u.x, u.y,
        u.hp, u.strength, u.magic, u.defense, u.resistance,
        u.precision, u.agility, u.luck,
        u.movement,
        ws2,
        u.activeWeapon
      )
  }


  def unitSymbol(u: gameUnbit): String =
    if (u.side == "player") "@" else "â˜ "
  def collectTargets(
  att: gameUnbit,
  attX: Int,
  attY: Int,
  units: List[gameUnbit],
  wAtt: Weapon
): List[gameUnbit] =
  units match {
    case Nil() => Nil()
    case Cons(u, rest) =>
      if (u.side != att.side && inRange(att, attX, attY, u, wAtt))
        Cons(u, collectTargets(att, attX, attY, rest, wAtt))
      else
        collectTargets(att, attX, attY, rest, wAtt)
  }
def dropEmpty(xs: List[String]): List[String] =
  xs match {
    case Nil() => Nil()
    case Cons(h, t) =>
      if (h.trim() == "") dropEmpty(t)
      else Cons(h, dropEmpty(t))
  }
def printTargets(ts: List[gameUnbit], i: Int): Unit =
  ts match {
    case Nil() => ()
    case Cons(u, rest) =>
      printString(
        unitSymbol(u) ++ " " ++ i.show ++
        " at (" ++ (u.x + 1).show ++ "," ++ (u.y + 1).show ++ ")" ++
        " HP=" ++ u.hp.show ++ "\n"
      )
      printTargets(rest, i + 1)
  }
  def inRange(
  att: gameUnbit,
  attX: Int,
  attY: Int,
  deff: gameUnbit,
  w: Weapon
): Bool =
  val (rmin, rmax) = w.range
  val d = manhattan(attX, attY, deff.x, deff.y)
  d >= rmin && d <= rmax

 def getWeaponAt(ws: List[Weapon], i: Int): Option[Weapon] =
   ws match {
    case Nil() => None()
     case Cons(w, rest) =>
       if (i == 0) Some(w) else getWeaponAt(rest, i - 1)
   }
  //menu starts here
def runMenu(
  map: GameMap,
  selected: Option[gameUnbit],
  reachable: List[TilePos],
  moveState: Option[MoveState],
  combatState: Option[CombatState]
): Unit = {

 def parseInput(line: String, combatState: Option[CombatState]): UIAction = {
  val trimmed = line.trim()

  combatState match {

   
    case Some(_) =>
      if (trimmed == "f") {
        ConfirmCombat()
      } else if (trimmed == "g") {
        CancelCombat()
      } else {

        CancelCombat()
      }

    case None() =>
      if (trimmed == "q") {
        Quit()
      } else if (trimmed == "m") {
        ShowMovement()
      } else if (trimmed == "w") {
        MoveCursor(0, -1)
      } else if (trimmed == "s") {
        MoveCursor(0, 1)
      } else if (trimmed == "a") {
        MoveCursor(-1, 0)
      } else if (trimmed == "d") {
        MoveCursor(1, 0)
      } else if (trimmed == "c") {
        CancelMove()
      } else if (trimmed == "r") {
        ConfirmMove()
      } else if (trimmed == "e") {
        ListTargets()
      } else {

        val toks = dropEmpty(split(trimmed, " "))

        toks match {


          case Cons("s", Cons(xs, Cons(ys, Nil()))) =>
            (parseIntOpt(xs), parseIntOpt(ys)) match {
              case (Some(x), Some(y)) =>
                SelectUnit(x - 1, y - 1)
              case _ =>
                ShowMovement()
            }


          case Cons(n, Nil()) =>
            parseIntOpt(n) match {
              case Some(i) => SwitchWeapon(i - 1)
              case None()  => ShowMovement()
            }

          case _ =>
            ShowMovement()
        }
      }
  }
}






 
  val buffer = ref(makeBuffer(map.width, map.height))
  
  withConsole(buffer, map, selected, reachable, moveState)
  selected match {
  case Some(u) =>
    printUnitStats(u)
    printWeapons(u)
  case None() =>
    printString("\n(No unit selected)\n")
}
  moveState match {
  case Some(Moving(_, _, _, _, _, rem)) =>
    printString("\nRemaining movement: " ++ rem.show ++ "\n")
  case None() => ()
}
  printBuffer(buffer.get())
   
 
  
  val c = newConsole()
  val line = readLine(c)
  closeConsole(c)
  dbg("readLine returned: '" ++ line ++ "'")
  dbg("dispatch action")
  val action = parseInput(line,combatState)
  action match {
    case Quit() =>
    printString("Bye!\n")
    ()
    case SelectUnit(x, y) =>
  dbg("SelectUnit(" ++ x.show ++ "," ++ y.show ++ ")")

  val newSelected = unitAt(map.units, x, y)

  dbg(
    "SelectUnit result: " ++
    (newSelected match {
      case Some(_) => "Some(unit)"
      case None()  => "None"
    })
  )

  
  runMenu(
    map,
    newSelected,
    Nil(),        
    None(),
    None()       
  )
   case MoveCursor(dx, dy) =>
  moveState match {
    case Some(Moving(u, sx, sy, cx, cy, rem)) =>
      val nx = cx + dx
      val ny = cy + dy

      val newRem =
        withGroundRules(map, u.x, u.y) {
          tryMove(nx, ny, rem)
        }

      val nextState =
        if (newRem >= 0 && newRem < rem)
          Some(Moving(u, sx, sy, nx, ny, newRem))
        else
          moveState

      runMenu(map, selected, reachable, nextState,None())
    case None() =>
      runMenu(map, selected, reachable, None(),None())
  }


  case CancelMove() =>
  runMenu(map, selected, reachable, None(), None())
  case ConfirmMove() =>    
  printString("[DBG] ConfirmMove pressed\n")     
    moveState match {
      case Some(Moving(u, sx, sy, cx, cy, _)) =>
        printString(
        "[DBG] Commit cursor at (" ++ cx.show ++ "," ++ cy.show ++ ")\n"
      )
        val moved =
          gameUnbit(
            u.side,
            cx, cy,
            u.hp,
            u.strength,
            u.magic,
            u.defense,
            u.resistance,
            u.precision,
            u.agility,
            u.luck,
            u.movement,
            u.weapons,
            u.activeWeapon
          )
        printString(
  "[DBG] New unit position = (" ++ moved.x.show ++ "," ++ moved.y.show ++ ")\n"
)
         val newUnits =
        replaceUnit(map.units, sx, sy, moved)

      val newMap =
        GameMap(map.width, map.height, map.tiles, newUnits)
        map.units.foreach { u =>
  printString(
    "[DBG] render unit at (" ++ u.x.show ++ "," ++ u.y.show ++ ")\n"
  )
}

      runMenu(newMap, Some(moved), Nil(), None(), None())

      case None() =>
        runMenu(map, selected, reachable, None(), None())
    }

   
  case ShowMovement() =>
  val newReachable =
    selected match {
      case Some(u) =>
        withGroundMovement(map, u)
      case None() =>
        Nil()
    }

  val newMoveState =
    selected match {
      case Some(u) =>
        if (u.side == "player")
          Some(Moving(u, u.x, u.y, u.x, u.y, u.movement))
        else
          None()   
      case None() =>
        None()
    }

  runMenu(
    map,
    selected,
    newReachable,
    newMoveState,
    None()
  )
    case SwitchWeapon(i) =>
  selected match {
    case Some(u) =>
      val updated = switchWeapon(u, i)

      
      val newUnits = replaceUnit(map.units, u.x, u.y, updated)

      val newMap =
        GameMap(map.width, map.height, map.tiles, newUnits)

      runMenu(newMap, Some(updated), reachable, moveState, None())

    case None() =>
      runMenu(map, selected, reachable, moveState, None())
  }
  case ListTargets() =>
  selected match {
    case Some(att) =>
      activeWeapon(att) match {
        case Some(wAtt) =>
          val (attX, attY) =
          moveState match {
            case Some(Moving(_, _, _, cx, cy, _)) => (cx, cy)
            case None()                           => (att.x, att.y)
          }

        val ts = collectTargets(att, attX, attY, map.units, wAtt)

        if (ts is Nil()) {
          printString("No targets in range.\n")
          runMenu(map, selected, reachable, moveState,None())
        } else {
          printString("\n=== TARGETS (press number) ===\n")
          printTargets(ts, 1)

          val c2 = newConsole()
          val line2 = readLine(c2)
          closeConsole(c2)


            val idxOpt = parseIntOpt(line2.trim())
            idxOpt match {
              case Some(k) =>
                val idx0 = k - 1
                val defOpt = listGet(ts, idx0)   
                defOpt match {
                  case Some(target) =>
                    activeWeapon(target) match {
                      case Some(wDef) =>

                       
                        val (sx, sy) =
                          moveState match {
                            case Some(Moving(_, sx0, sy0, _, _, _)) => (sx0, sy0)
                            case None() => (att.x, att.y)
                          }

                        val (ax, ay) =
                          moveState match {
                            case Some(Moving(_, _, _, cx, cy, _)) => (cx, cy)
                            case None() => (att.x, att.y)
                          }

                        
                        val attAtCursor =
                          gameUnbit(
                            att.side,
                            ax, ay,
                            att.hp,
                            att.strength, att.magic, att.defense, att.resistance,
                            att.precision, att.agility, att.luck,
                            att.movement,
                            att.weapons,
                            att.activeWeapon
                          )

                        val p = previewPure(attAtCursor, target, wAtt, wDef)

                        val cs =
                          CombatState(attAtCursor, sx, sy, ax, ay, target, wAtt, wDef, p)

                        printPreview(cs)
                        runMenu(map, selected, reachable, moveState, Some(cs))

                      case None() =>
                        printString("Defender has no weapon.\n")
                        runMenu(map, selected, reachable, moveState, combatState)
                    }

                    
                  case None() =>
                    printString("Invalid target.\n")
                    runMenu(map, selected, reachable, moveState, None())
                }

              case None() =>
                printString("Invalid number.\n")
                runMenu(map, selected, reachable, moveState, None())
            }
          }

        case None() =>
          printString("No active weapon.\n")
          runMenu(map, selected, reachable, moveState, None())
      }

    case None() =>
      printString("No unit selected.\n")
      runMenu(map, selected, reachable, moveState, None())
  }
  case CancelCombat() =>
 
  runMenu(map, selected, reachable, moveState, None())

case ConfirmCombat() =>
  try {
    combatState match {
      case None() =>
        runMenu(map, selected, reachable, moveState, None())

      case Some(cs) =>
        
        val att0 = decWeaponUse(cs.attacker)
        val att0AtCursor =
          gameUnbit(
            att0.side,
            cs.attackerX, cs.attackerY,
            att0.hp,
            att0.strength, att0.magic, att0.defense, att0.resistance,
            att0.precision, att0.agility, att0.luck,
            att0.movement,
            att0.weapons,
            att0.activeWeapon
          )
        val def0 = cs.defender

        activeWeapon(att0) match {
          case None() =>
            runMenu(map, selected, reachable, None(), None())

          case Some(wAttNow) =>
            activeWeapon(def0) match {
              case None() =>
                runMenu(map, selected, reachable, None(), None())

              case Some(wDefNow) =>
                val pAtt = previewPure(att0, def0, wAttNow, wDefNow)
                val r1   = resolveAttack(att0, def0, pAtt)
                val def1 = applyDamage(def0, r1.damage)

                printString(
                  "\nATTACKER: " ++
                  (if (r1.hit) "HIT" else "MISS") ++
                  (if (r1.crit) " (CRIT)" else "") ++
                  " dmg=" ++ r1.damage.show ++ "\n"
                )

                val unitsA =
                  replaceUnit(map.units, cs.attackerStartX, cs.attackerStartY, att0AtCursor)

                
                val units1 =
                  replaceUnit(unitsA, def0.x, def0.y, def1)

                val map1 =
                  GameMap(map.width, map.height, map.tiles, units1)

                if (not(alive(def1))) {
                  printString("Defender defeated.\n")
                  runMenu(map1, Some(att0), Nil(), None(), None())
                } else {
                  val canCounter =
                    inRange(def1, def1.x, def1.y, att0, wDefNow)

                  if (canCounter) {
                    val pDef = previewPure(def1, att0, wDefNow, wAttNow)
                    val r2   = resolveAttack(def1, att0, pDef)
                    val att1 = applyDamage(att0, r2.damage)

                    printString(
                      "DEFENDER: " ++
                      (if (r2.hit) "HIT" else "MISS") ++
                      (if (r2.crit) " (CRIT)" else "") ++
                      " dmg=" ++ r2.damage.show ++ "\n"
                    )

                    val units2 =
                      replaceUnit(map1.units, cs.attackerX, cs.attackerY, att1)

                    val map2   = GameMap(map1.width, map1.height, map1.tiles, units2)

                    runMenu(map2, Some(att1), Nil(), None(), None())
                  } else {
                    printString("No counterattack.\n")
                    runMenu(map1, Some(att0), Nil(), None(), None())
                  }
                }
            }
        }
    }
  } with roll { max =>
  val m: Int = if (max <= 0) 1 else max
  val r: Int = randInt(m)   
  resume(r)
}



  

  }




 




  }

