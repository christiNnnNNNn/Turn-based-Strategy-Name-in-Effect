module menu

import src/maploader
import src/model
import src/movement
import src/renderer
import string


extern type JSConsole






extern def readFile(path: String) at io: String =
  jsNode """
    require('fs').readFileSync(${path}, 'utf8')
  """

extern def printString(s: String) at io: Unit =
  jsNode "process.stdout.write(${s})"

extern def readLine(console: JSConsole) at async: String =
    jsNode "$effekt.capture(k => ${console}.once('line', k))"
extern def newConsole() at io: JSConsole =
    jsNode """readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })"""
extern def closeConsole(c: JSConsole) at io: Unit =
  jsNode "${c}.close()"

type UIAction {
  Quit()
  SelectUnit(x: Int, y: Int)
  ShowMovement()
  SwitchWeapon(index: Int)
  MoveCursor(dx: Int, dy: Int)
  CancelMove()
  ConfirmMove() 
  }





def isReachable(x: Int, y: Int, rs: List[TilePos]): Bool =
  rs match {
    case Nil() => false
    case Cons(p, rest) =>
      if (p.x == x && p.y == y) true
      else isReachable(x, y, rest)
  }

def unitAtPos(
  units: List[gameUnbit],
  x: Int,
  y: Int
): Option[gameUnbit] =
  units match {
    case Nil() => None()
    case Cons(u, rest) =>
      if (u.x == x && u.y == y) Some(u)
      else unitAtPos(rest, x, y)
  }
def tileAt(
  tiles: List[List[Tile]],
  x: Int,
  y: Int
): Tile =
  tiles match {
    case Nil() =>
      TileWall()   

    case Cons(row, rest) =>
      if (y == 0) tileAtRow(row, x)
      else tileAt(rest, x, y - 1)
  }

def tileAtRow(row: List[Tile], x: Int): Tile =
  row match {
    case Nil() =>
      TileWall()

    case Cons(t, rest) =>
      if (x == 0) t
      else tileAtRow(rest, x - 1)
  }

def switchWeapon(
  u: gameUnbit,
  newIndex: Int
): gameUnbit = {

  def weaponCount(ws: List[Weapon]): Int =
    ws match {
      case Nil() => 0
      case Cons(_, rest) => 1 + weaponCount(rest)
    }

  val count = weaponCount(u.weapons)

  if (
    u.side == "player" &&
    newIndex >= 0 &&
    newIndex < count
  )
    gameUnbit(
      u.side,
      u.x,
      u.y,
      u.hp,
      u.strength,
      u.magic,
      u.defense,
      u.resistance,
      u.precision,
      u.agility,
      u.luck,
      u.movement,
      u.weapons,
      newIndex       
    )
  else
    u
}
def replaceUnit(
  units: List[gameUnbit],
  oldX: Int,
  oldY: Int,
  updated: gameUnbit
): List[gameUnbit] =
  units match {
    case Nil() => Nil()

    case Cons(u, rest) =>
      if (u.x == oldX && u.y == oldY)
        Cons(updated, rest)
      else
        Cons(u, replaceUnit(rest, oldX, oldY, updated))
  }

def parseWeaponIndex(line: String): Option[Int] =
  try {
    Some(line.toInt1)
  } with Exception[WrongFormat] {
    def raise(_, _) = None()
  }

def parseIntOpt(s: String): Option[Int] =
  try {
    Some(s.toInt)
  } with Exception[WrongFormat] {
    def raise(_, _) = None()
  }


def dropEmpty(xs: List[String]): List[String] =
  xs match {
    case Nil() => Nil()
    case Cons(h, t) =>
      if (h.trim() == "") dropEmpty(t)
      else Cons(h, dropEmpty(t))
  }

def runMenu(
  map: GameMap,
  selected: Option[gameUnbit],
  reachable: List[TilePos],
  moveState: Option[MoveState]
): Unit = {
 def parseInput(line: String): UIAction = {
  val trimmed = line.trim()
  dbg("parseInput raw='" ++ line ++ "' trimmed='" ++ trimmed ++ "'")
  if (trimmed == "q") {
     dbg("parseInput -> Quit")
    Quit()
  } else if (trimmed == "m") {
     dbg("parseInput -> ShowMovement")
    ShowMovement()
    }else if (trimmed == "w")  {
       dbg("parseInput -> MoveCursor(0,-1)")
       MoveCursor(0, -1)}
    else if (trimmed == "s")  {MoveCursor(0, 1)}
    else if (trimmed == "a")  {MoveCursor(-1, 0)}
    else if (trimmed == "d")  {MoveCursor(1, 0)}
    else if (trimmed == "c")  {CancelMove()}
    else if (trimmed == "r") {
  ConfirmMove()
}
   else {
    val toks = dropEmpty(split(trimmed, " "))

    toks match {
      
      case Cons("s", Cons(xs, Cons(ys, Nil()))) =>
        (parseIntOpt(xs), parseIntOpt(ys)) match {
          case (Some(x), Some(y)) =>
          
            SelectUnit(x - 1, y - 1)

          case _ =>
            printString("Invalid coordinates\n")
            ShowMovement()
        }

      
      case Cons(n, Nil()) =>
        parseIntOpt(n) match {
          case Some(i) => SwitchWeapon(i - 1)
          case None() =>
            printString("Invalid command\n")
            ShowMovement()
        }

      case _ =>
        printString("Invalid command\n")
        ShowMovement()
    }
  }
}




 
  val buffer = ref(makeBuffer(map.width, map.height))
  
  withConsole(buffer, map, selected, reachable, moveState)
  selected match {
  case Some(u) =>
    printUnitStats(u)
    printWeapons(u)
  case None() =>
    printString("\n(No unit selected)\n")
}
  moveState match {
  case Some(Moving(_, _, _, _, _, rem)) =>
    printString("\nRemaining movement: " ++ rem.show ++ "\n")
  case None() => ()
}
  printBuffer(buffer.get())
   
 
  
  val c = newConsole()
  val line = readLine(c)
  closeConsole(c)
  dbg("readLine returned: '" ++ line ++ "'")
  dbg("dispatch action")
  val action = parseInput(line)
  action match {
    case Quit() =>
    printString("Bye!\n")
    ()
    case SelectUnit(x, y) =>
  dbg("SelectUnit(" ++ x.show ++ "," ++ y.show ++ ")")

  val newSelected = unitAt(map.units, x, y)

  dbg(
    "SelectUnit result: " ++
    (newSelected match {
      case Some(_) => "Some(unit)"
      case None()  => "None"
    })
  )

  
  runMenu(
    map,
    newSelected,
    Nil(),        
    None()       
  )
   case MoveCursor(dx, dy) =>
  moveState match {
    case Some(Moving(u, sx, sy, cx, cy, rem)) =>
      val nx = cx + dx
      val ny = cy + dy

      val newRem =
        withGroundRules(map, u.x, u.y) {
          tryMove(nx, ny, rem)
        }

      val nextState =
        if (newRem >= 0 && newRem < rem)
          Some(Moving(u, sx, sy, nx, ny, newRem))
        else
          moveState

      runMenu(map, selected, reachable, nextState)

    case None() =>
      runMenu(map, selected, reachable, None())
  }


  case CancelMove() =>
  runMenu(map, selected, reachable, None())
  case ConfirmMove() =>    
  printString("[DBG] ConfirmMove pressed\n")     
    moveState match {
      case Some(Moving(u, sx, sy, cx, cy, _)) =>
        printString(
        "[DBG] Commit cursor at (" ++ cx.show ++ "," ++ cy.show ++ ")\n"
      )
        val moved =
          gameUnbit(
            u.side,
            cx, cy,
            u.hp,
            u.strength,
            u.magic,
            u.defense,
            u.resistance,
            u.precision,
            u.agility,
            u.luck,
            u.movement,
            u.weapons,
            u.activeWeapon
          )
        printString(
  "[DBG] New unit position = (" ++ moved.x.show ++ "," ++ moved.y.show ++ ")\n"
)
         val newUnits =
        replaceUnit(map.units, sx, sy, moved)

      val newMap =
        GameMap(map.width, map.height, map.tiles, newUnits)
        map.units.foreach { u =>
  printString(
    "[DBG] render unit at (" ++ u.x.show ++ "," ++ u.y.show ++ ")\n"
  )
}

      runMenu(newMap, Some(moved), Nil(), None())

      case None() =>
        runMenu(map, selected, reachable, None())
    }

   
  case ShowMovement() =>
  val newReachable =
    selected match {
      case Some(u) =>
        withGroundMovement(map, u)
      case None() =>
        Nil()
    }

  val newMoveState =
    selected match {
      case Some(u) =>
        if (u.side == "player")
          Some(Moving(u, u.x, u.y, u.x, u.y, u.movement))
        else
          None()   
      case None() =>
        None()
    }

  runMenu(
    map,
    selected,
    newReachable,
    newMoveState
  )
    case SwitchWeapon(i) =>
  selected match {
    case Some(u) =>
      val updated = switchWeapon(u, i)

      
      val newUnits = replaceUnit(map.units, u.x, u.y, updated)

      val newMap =
        GameMap(map.width, map.height, map.tiles, newUnits)

      runMenu(newMap, Some(updated), reachable, moveState)

    case None() =>
      runMenu(map, selected, reachable, moveState)
  }


  }




 




  }

