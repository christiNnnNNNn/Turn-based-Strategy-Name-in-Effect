module menu

import src/maploader
import src/model
import src/movement
import src/renderer
import src/combat
import string


extern type JSConsole

extern def readFile(path: String) at io: String =
  jsNode """
    require('fs').readFileSync(${path}, 'utf8')
  """

extern def printString(s: String) at io: Unit =
  jsNode "process.stdout.write(${s})"

extern def readLine(console: JSConsole) at async: String =
    jsNode "$effekt.capture(k => ${console}.once('line', k))"
extern def newConsole() at io: JSConsole =
    jsNode """readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })"""
extern def closeConsole(c: JSConsole) at io: Unit =
  jsNode "${c}.close()"

type UIAction {
  Quit()
  SelectUnit(x: Int, y: Int)
  ShowMovement()
  SwitchWeapon(index: Int)
  MoveCursor(dx: Int, dy: Int)
  CancelMove()
  ConfirmMove() 
  ListTargets()       
  ConfirmCombat()     
  CancelCombat() 
  EndTurn()     
  }

record CombatState(
  attacker: gameUnbit,
  attackerStartX: Int,
  attackerStartY: Int,
  attackerX: Int,
  attackerY: Int,
  defender: gameUnbit,
  wAtt: Weapon,
  wDef: Weapon,
  preview: CombatPreview
)








def unitAtPos(
  units: List[gameUnbit],
  x: Int,
  y: Int
): Option[gameUnbit] =
  units match {
    case Nil() => None()
    case Cons(u, rest) =>
      if (u.x == x && u.y == y) Some(u)
      else unitAtPos(rest, x, y)
  }
def tileAt(
  tiles: List[List[Tile]],
  x: Int,
  y: Int
): Tile =
  tiles match {
    case Nil() =>
      TileWall()   

    case Cons(row, rest) =>
      if (y == 0) tileAtRow(row, x)
      else tileAt(rest, x, y - 1)
  }

def tileAtRow(row: List[Tile], x: Int): Tile =
  row match {
    case Nil() =>
      TileWall()

    case Cons(t, rest) =>
      if (x == 0) t
      else tileAtRow(rest, x - 1)
  }
def printPreview(cs: CombatState): Unit =
  printString(
    "\n=== COMBAT PREVIEW ===\n" ++
    "Target at (" ++ (cs.defender.x + 1).show ++ "," ++ (cs.defender.y + 1).show ++ ")\n" ++
    "DAMAGE = " ++ cs.preview.dmg.show ++ "\n" ++
    "HIT%   = " ++ cs.preview.hit.show ++ "\n" ++
    "CRIT%  = " ++ cs.preview.crit.show ++ "\n" ++
    "Confirm: f   Cancel: g\n"
   )
def switchWeapon(
  u: gameUnbit,
  newIndex: Int
): gameUnbit = {

  def weaponCount(ws: List[Weapon]): Int =
    ws match {
      case Nil() => 0
      case Cons(_, rest) => 1 + weaponCount(rest)
    }

  val count = weaponCount(u.weapons)

  if (
    u.side == "player" &&
    newIndex >= 0 &&
    newIndex < count
  )
    gameUnbit(
      u.side,
      u.x,
      u.y,
      u.hp,
      u.strength,
      u.magic,
      u.defense,
      u.resistance,
      u.precision,
      u.agility,
      u.luck,
      u.movement,
      u.weapons,
      newIndex,
      u.moved,
      u.symbol       
    )
  else
    u
}
def replaceUnit(
  units: List[gameUnbit],
  oldX: Int,
  oldY: Int,
  updated: gameUnbit
): List[gameUnbit] =
  units match {
    case Nil() => Nil()

    case Cons(u, rest) =>
      if (u.x == oldX && u.y == oldY)
        Cons(updated, rest)
      else
        Cons(u, replaceUnit(rest, oldX, oldY, updated))
  }
def resetMoved(units: List[gameUnbit]): List[gameUnbit] =
  units match {
    case Nil() => Nil()
    case Cons(u, rest) =>
      val u2 =
        if (u.side == "player")
          gameUnbit(
            u.side, u.x, u.y,
            u.hp, u.strength, u.magic, u.defense, u.resistance,
            u.precision, u.agility, u.luck,
            u.movement,
            u.weapons,
            u.activeWeapon,
            false,
            u.symbol
          )
        else
          u
      Cons(u2, resetMoved(rest))
  }
def parseWeaponIndex(line: String): Option[Int] =
  try {
    Some(line.toInt1)
  } with Exception[WrongFormat] {
    def raise(_, _) = None()
  }

def digitOpt(c: String): Option[Int] =
  if (c == "0") Some(0)
  else if (c == "1") Some(1)
  else if (c == "2") Some(2)
  else if (c == "3") Some(3)
  else if (c == "4") Some(4)
  else if (c == "5") Some(5)
  else if (c == "6") Some(6)
  else if (c == "7") Some(7)
  else if (c == "8") Some(8)
  else if (c == "9") Some(9)
  else None()

def parseNatOpt(s: String): Option[Int] =
  val t = s.trim()
  if (t.length() == 0) None()
  else {
    def loop(i: Int, acc: Int): Option[Int] =
      if (i >= t.length()) Some(acc)
      else
        digitOpt(t.substring(i, i + 1)) match {
          case None() => None()
          case Some(d) => loop(i + 1, acc * 10 + d)
        }

    loop(0, 0)
  }

def parseIntOpt(s: String): Option[Int] =

  parseNatOpt(s)



def setWeaponAt(ws: List[Weapon], i: Int, nw: Weapon): List[Weapon] =
  ws match {
    case Nil() => Nil()
    case Cons(w, rest) =>
      if (i == 0) Cons(nw, rest)
      else Cons(w, setWeaponAt(rest, i - 1, nw))
  }
def effectivePosition(
  selected: Option[gameUnbit],
  moveState: Option[MoveState]
): Option[(gameUnbit, Int, Int)] =
  moveState match {
    case Some(Moving(u, _, _, cx, cy, _)) =>
      Some((u, cx, cy))
    case None() =>
      selected match {
        case Some(u) => Some((u, u.x, u.y))
        case None()  => None()
      }
  }
def activeWeapon(u: gameUnbit): Option[Weapon] =
  getWeaponAt(u.weapons, u.activeWeapon)

def decWeaponUse(u: gameUnbit): gameUnbit =
  activeWeapon(u) match {
    case None() => u
    case Some(w) =>
      val newUses = max(0, w.uses - 1)
      val w2 = Weapon(w.name, w.kind, w.damageType, w.attack, w.hit, newUses, w.crit,w.range, w.mods)
      val ws2 = setWeaponAt(u.weapons, u.activeWeapon, w2)
      gameUnbit(
        u.side, u.x, u.y,
        u.hp, u.strength, u.magic, u.defense, u.resistance,
        u.precision, u.agility, u.luck,
        u.movement,
        ws2,
        u.activeWeapon,
        u.moved,
        u.symbol
      )
  }


  def unitSymbol(u: gameUnbit): String =
    u.symbol
  def collectTargets(
  att: gameUnbit,
  attX: Int,
  attY: Int,
  units: List[gameUnbit],
  wAtt: Weapon
): List[gameUnbit] =
  units match {
    case Nil() => Nil()
    case Cons(u, rest) =>
      if (u.side != att.side && inRange(att, attX, attY, u, wAtt))
        Cons(u, collectTargets(att, attX, attY, rest, wAtt))
      else
        collectTargets(att, attX, attY, rest, wAtt)
  }
def dropEmpty(xs: List[String]): List[String] =
  xs match {
    case Nil() => Nil()
    case Cons(h, t) =>
      if (h.trim() == "") dropEmpty(t)
      else Cons(h, dropEmpty(t))
  }
def printTargets(ts: List[gameUnbit], i: Int): Unit =
  ts match {
    case Nil() => ()
    case Cons(u, rest) =>
      printString(
        unitSymbol(u) ++ " " ++ i.show ++
        " at (" ++ (u.x + 1).show ++ "," ++ (u.y + 1).show ++ ")" ++
        " HP=" ++ u.hp.show ++ "\n"
      )
      printTargets(rest, i + 1)
  }
 def inRange(
  att: gameUnbit,
  attX: Int,
  attY: Int,
  deff: gameUnbit,
  w: Weapon
): Bool =
  w.range match {
    case (rmin, rmax) =>
      val d = manhattan(attX, attY, deff.x, deff.y)
      if (d < rmin) false
      else if (d > rmax) false
      else true
  }


 def getWeaponAt(ws: List[Weapon], i: Int): Option[Weapon] =
   ws match {
    case Nil() => None()
     case Cons(w, rest) =>
       if (i == 0) Some(w) else getWeaponAt(rest, i - 1)
   }

   def absInt(n: Int): Int =
  if (n < 0) 0 - n else n

def nearestPlayer(enemy: gameUnbit, units: List[gameUnbit]): Option[gameUnbit] = {
  def loop(
    xs: List[gameUnbit],
    best: Option[gameUnbit],
    bestD: Int
  ): Option[gameUnbit] =
    xs match {
      case Nil() => best
      case Cons(u, rest) =>
        if (u.side == "player") {
          val d = manhattan(enemy.x, enemy.y, u.x, u.y)
          best match {
            case None() => loop(rest, Some(u), d)
            case Some(_) =>
              if (d < bestD)
                loop(rest, Some(u), d)
              else
                loop(rest, best, bestD)
          }
        } else
          loop(rest, best, bestD)
    }

  loop(units, None(), 999999)
}


  def resolveAttackPure(att: gameUnbit, deff: gameUnbit, p: CombatPreview): AttackResult / {} =
  try { resolveAttack(att, deff, p) }
  with roll { max =>
    val m: Int = if (max <= 0) 1 else max
    resume(randInt(m))
  }
def bestReachForRange(
  reach: List[TilePos],
  tx: Int, ty: Int,
  rmin: Int, rmax: Int
): Option[TilePos] = {
  def loop(
    rs: List[TilePos],
    best: Option[TilePos],
    bestScore: Int,
    bestDist: Int
  ): Option[TilePos] =
    rs match {
      case Nil() => best
      case Cons(p, rest) =>
        val d = manhattan(p.x, p.y, tx, ty)

        val score =
          if (d < rmin) rmin - d
          else if (d > rmax) d - rmax
          else 0

        best match {
          case None() =>
            loop(rest, Some(p), score, d)

          case Some(_) =>
            if (score < bestScore || (score == bestScore && d < bestDist))
              loop(rest, Some(p), score, d)
            else
              loop(rest, best, bestScore, bestDist)
        }
    }

  loop(reach, None(), 999999, 999999)
}

def afterPlayerCombat(m: GameMap): Unit =
 
  endOrContinue(m) { mm =>
    runMenu(mm, None(), Nil(), None(), None())
  }

  def bestReachToward(reach: List[TilePos], tx: Int, ty: Int): Option[TilePos] =
  {def loop(rs: List[TilePos], best: Option[TilePos], bestD: Int): Option[TilePos] =
    rs match {
      case Nil() => best
      case Cons(p, rest) =>
        val d = manhattan(p.x, p.y, tx, ty)
        best match {
          case None() => loop(rest, Some(p), d)
          case Some(_) =>
            if (d < bestD) loop(rest, Some(p), d) else loop(rest, best, bestD)
        }
    }
  loop(reach, None(), 999999)
  }
  

  def isPlayer(u: gameUnbit): Bool = u.side == "player"
def isEnemy(u: gameUnbit): Bool = u.side == "enemy"
def enemyPhase(map: GameMap): GameMap = {

  def onlyPlayers(xs: List[gameUnbit]): List[gameUnbit] =
    xs match {
      case Nil() => Nil()
      case Cons(u, rest) =>
        if (isPlayer(u)) Cons(u, onlyPlayers(rest))
        else onlyPlayers(rest)
    }

  def stepEnemy(cur: GameMap, e0: gameUnbit): GameMap =
    cleanupMap(
    if (not(isEnemy(e0)) || not(alive(e0))) cur
    else {
      nearestPlayer(e0, cur.units) match {
        case None() => cur
        case Some(tgt) =>

          val reach = withGroundMovement(cur, e0)

          val destOpt =
            activeWeapon(e0) match {
              case None() =>
                bestReachToward(reach, tgt.x, tgt.y)

              case Some(wE0) =>
                wE0.range match {
                  case (rmin, rmax) =>
                    bestReachForRange(reach, tgt.x, tgt.y, rmin, rmax)
                }
            }

          val e1 =
            destOpt match {
              case None() => e0
              case Some(TilePos(nx, ny)) =>
                gameUnbit(
                  e0.side, nx, ny,
                  e0.hp, e0.strength, e0.magic, e0.defense, e0.resistance,
                  e0.precision, e0.agility, e0.luck,
                  e0.movement,
                  e0.weapons, e0.activeWeapon,
                  e0.moved,
                  e0.symbol
                )
            }

          // commit movement
          val unitsMoved = replaceUnit(cur.units, e0.x, e0.y, e1)
          val mapMoved   = GameMap(cur.width, cur.height, cur.tiles, unitsMoved)

          // attack (enemy -> player)
          activeWeapon(e1) match {
            case None() => mapMoved
            case Some(wE) =>
              val ts  = collectTargets(e1, e1.x, e1.y, mapMoved.units, wE)
              val ts2 = onlyPlayers(ts)

              ts2 match {
                case Nil() => mapMoved
                case Cons(defU, _) =>

                  // enemy strikes
                  activeWeapon(defU) match {
                    case None() =>
                      val pE  = previewPure(e1, defU, wE, wE)
                      val r1  = resolveAttackPure(e1, defU, pE)
                      val def1 = applyDamage(defU, r1.damage)

                      printString(
                        "\nENEMY ATTACK: " ++
                        (if (r1.hit) "HIT" else "MISS") ++
                        (if (r1.crit) " (CRIT)" else "") ++
                        " dmg=" ++ r1.damage.show ++ "\n"
                      )

                      val unitsAfter = replaceUnit(mapMoved.units, defU.x, defU.y, def1)
                      GameMap(mapMoved.width, mapMoved.height, mapMoved.tiles, unitsAfter)

                    case Some(wP) =>
                      val pE  = previewPure(e1, defU, wE, wP)
                      val r1  = resolveAttackPure(e1, defU, pE)
                      val def1 = applyDamage(defU, r1.damage)

                      printString(
                        "\nENEMY ATTACK: " ++
                        (if (r1.hit) "HIT" else "MISS") ++
                        (if (r1.crit) " (CRIT)" else "") ++
                        " dmg=" ++ r1.damage.show ++ "\n"
                      )

                      val units1 = replaceUnit(mapMoved.units, defU.x, defU.y, def1)
                      val map1   = GameMap(mapMoved.width, mapMoved.height, mapMoved.tiles, units1)

                     
                      if (alive(def1) && canCounter(def1, e1, wP)) {

                        
                        val defCounter0 = decWeaponUse(def1)

                       
                        activeWeapon(defCounter0) match {
                          case None() =>
                            map1

                          case Some(wPCur) =>
                            val pC = previewPure(defCounter0, e1, wPCur, wE)
                            val r2 = resolveAttackPure(defCounter0, e1, pC)
                            val e2 = applyDamage(e1, r2.damage)

                            printString(
                              "PLAYER COUNTER: " ++
                              (if (r2.hit) "HIT" else "MISS") ++
                              (if (r2.crit) " (CRIT)" else "") ++
                              " dmg=" ++ r2.damage.show ++ "\n"
                            )

                            
                            val unitsA =
                              replaceUnit(map1.units, def1.x, def1.y, defCounter0)

                            
                            val unitsB =
                              replaceUnit(unitsA, e1.x, e1.y, e2)

                            GameMap(map1.width, map1.height, map1.tiles, unitsB)
                        }

                      } else {
                        map1
                      }
                  }
              }
          }
      }
    }
    )

  def loopEnemies(xs: List[gameUnbit], cur: GameMap): GameMap =
    xs match {
      case Nil() => cur
      case Cons(u, rest) =>
        // refresh unit from current map (it may have moved earlier)
        val uNow =
          unitAt(cur.units, u.x, u.y) match {
            case Some(u2) => u2
            case None()   => u
          }
        loopEnemies(rest, stepEnemy(cur, uNow))
    }

  loopEnemies(map.units, map)
}


def cleanupAndCheckGameOver(
  map: GameMap,
  selected: Option[gameUnbit],
  reachable: List[TilePos],
  moveState: Option[MoveState],
  combatState: Option[CombatState]
): Unit =
  val cleanedMap = cleanupMap(map)
  val us = cleanedMap.units

  val playerAlive = sideHasUnits(us, "player")
  val enemyAlive  = sideHasUnits(us, "enemy")

  if (playerAlive && enemyAlive) {
    runMenu(cleanedMap, selected, reachable, moveState, combatState)
  } else {
    
    val buffer = ref(makeBuffer(cleanedMap.width, cleanedMap.height))
    withConsole(buffer, cleanedMap, selected, reachable, moveState)
    printBuffer(buffer.get())

    if (playerAlive && not(enemyAlive))
      printString("\n*** YOU WIN! ***\n")
    else if (not(playerAlive) && enemyAlive)
      printString("\n*** YOU LOSE! ***\n")
    else
      printString("\n*** DRAW ***\n")
    ()
  }

def endOrContinue(map: GameMap) { next: GameMap => Unit }: Unit =
  val m = cleanupMap(map)
  val pAlive = sideHasUnits(m.units, "player")
  val eAlive = sideHasUnits(m.units, "enemy")

  if (pAlive && eAlive) next(m)
  else if (pAlive) { printString("\n*** YOU WIN! ***\n"); () }
  else { printString("\n*** YOU LOSE! ***\n"); () }


 def canCounter(
  defU: gameUnbit,
  attU: gameUnbit,
  wDef: Weapon
): Bool =
  val (rmin, rmax) = wDef.range
  val d = manhattan(defU.x, defU.y, attU.x, attU.y)
  d >= rmin && d <= rmax

  //menu starts here
def runMenu(
  map: GameMap,
  selected: Option[gameUnbit],
  reachable: List[TilePos],
  moveState: Option[MoveState],
  combatState: Option[CombatState]
): Unit = {

 def parseInput(line: String, combatState: Option[CombatState], moveState: Option[MoveState]): UIAction = {
  val trimmed = line.trim()

  combatState match {
 
    case Some(_) =>
      if (trimmed == "f") ConfirmCombat()
      else if (trimmed == "g") CancelCombat()
      else CancelCombat()

   
    case None() =>
      if (trimmed == "q") Quit()
      else if (trimmed == "m") ShowMovement()
      else if (trimmed == "w") MoveCursor(0, -1)
      else if (trimmed == "s") MoveCursor(0, 1)
      else if (trimmed == "a") MoveCursor(-1, 0)
      else if (trimmed == "d") MoveCursor(1, 0)
      else if (trimmed == "r") ConfirmMove()
      else if (trimmed == "t") ListTargets()

    
      else if (trimmed == "x") EndTurn()

      
      else if (trimmed == "c") CancelMove()

      else {
        val toks = dropEmpty(split(trimmed, " "))

        toks match {
          case Cons("s", Cons(xs, Cons(ys, Nil()))) =>
            (parseIntOpt(xs), parseIntOpt(ys)) match {
              case (Some(x), Some(y)) => SelectUnit(x - 1, y - 1)
              case _                  => ShowMovement()
            }

          case Cons(n, Nil()) =>
            parseIntOpt(n) match {
              case Some(i) => SwitchWeapon(i - 1)
              case None()  => ShowMovement()
            }

          case _ =>
            ShowMovement()
        }
      }
  }
}

  val buffer = ref(makeBuffer(map.width, map.height))
  
  withConsole(buffer, map, selected, reachable, moveState)
  selected match {
  case Some(u) =>
    printUnitStats(u)
    printWeapons(u)
  case None() =>
    printString("\n(No unit selected)\n")
}
  moveState match {
  case Some(Moving(_, _, _, _, _, rem)) =>
    printString("\nRemaining movement: " ++ rem.show ++ "\n")
  case None() => ()
}
  printBuffer(buffer.get())

  val c = newConsole()
  val line = readLine(c)
  closeConsole(c)
  dbg("readLine returned: '" ++ line ++ "'")
  dbg("dispatch action")
  val action = parseInput(line,combatState, moveState)
  action match {
    case Quit() =>
      printString("Bye!\n")
      ()
    case SelectUnit(x, y) =>
      dbg("SelectUnit(" ++ x.show ++ "," ++ y.show ++ ")")

      val selOpt = unitAt(map.units, x, y)

      dbg(
        "SelectUnit result: " ++
        (selOpt match {
          case Some(_) => "Some(unit)"
          case None()  => "None"
        })
      )
      val newSelected =
      selOpt match {
        case Some(u) =>
          if (u.side == "player" && u.moved) {
            printString("That unit already moved this turn.\n")
            None()
          } else Some(u)
        case None() =>
          None()
      }
      
      runMenu(
        map,
        newSelected,
        Nil(),        
        None(),
        None()       
      )
   case MoveCursor(dx, dy) =>
    moveState match {
      case Some(Moving(u, sx, sy, cx, cy, rem)) =>
        val nx = cx + dx
        val ny = cy + dy

        val newRem =
          withGroundRules(map, u.x, u.y) {
            tryMove(nx, ny, rem)
          }

        val nextState =
          if (newRem >= 0 && newRem < rem)
            Some(Moving(u, sx, sy, nx, ny, newRem))
          else
            moveState

        runMenu(map, selected, reachable, nextState,None())
      case None() =>
        runMenu(map, selected, reachable, None(),None())
    }


  case CancelMove() =>
    runMenu(map, selected, reachable, None(), None())
    case ConfirmMove() =>    
    printString("[DBG] ConfirmMove pressed\n")     
      moveState match {
        case Some(Moving(u, sx, sy, cx, cy, _)) =>
          printString(
          "[DBG] Commit cursor at (" ++ cx.show ++ "," ++ cy.show ++ ")\n"
        )
          val moved =
            gameUnbit(
              u.side,
              cx, cy,
              u.hp,
              u.strength,
              u.magic,
              u.defense,
              u.resistance,
              u.precision,
              u.agility,
              u.luck,
              u.movement,
              u.weapons,
              u.activeWeapon,
              true,
              u.symbol
            )
          printString(
    "[DBG] New unit position = (" ++ moved.x.show ++ "," ++ moved.y.show ++ ")\n"
  )
          val newUnits =
          replaceUnit(map.units, sx, sy, moved)

        val newMap =
          GameMap(map.width, map.height, map.tiles, newUnits)
          map.units.foreach { u =>
    printString(
      "[DBG] render unit at (" ++ u.x.show ++ "," ++ u.y.show ++ ")\n"
    )
  }

        runMenu(newMap, Some(moved), Nil(), None(), None())

        case None() =>
          runMenu(map, selected, reachable, None(), None())
      }

   
  case ShowMovement() =>
      val newReachable =
        selected match {
          case Some(u) =>
            withGroundMovement(map, u)
          case None() =>
            Nil()
        }

      val newMoveState =
        selected match {
          case Some(u) =>
            if (u.side == "player")
              Some(Moving(u, u.x, u.y, u.x, u.y, u.movement))
            else
              None()   
          case None() =>
            None()
        }

      runMenu(
        map,
        selected,
        newReachable,
        newMoveState,
        None()
      )
    case SwitchWeapon(i) =>
  selected match {
    case Some(u) =>
      val updated = switchWeapon(u, i)

      
      val newUnits = replaceUnit(map.units, u.x, u.y, updated)

      val newMap =
        GameMap(map.width, map.height, map.tiles, newUnits)

      runMenu(newMap, Some(updated), reachable, moveState, None())

    case None() =>
      runMenu(map, selected, reachable, moveState, None())
  }
  case ListTargets() =>
    selected match {
      case Some(att) =>
      if (att.side != "player") {
          printString("You can only attack with player units.\n")
          runMenu(map, selected, reachable, moveState, combatState)
        } else {
        activeWeapon(att) match {
          case Some(wAtt) =>
            val (attX, attY) =
            moveState match {
              case Some(Moving(_, _, _, cx, cy, _)) => (cx, cy)
              case None()                           => (att.x, att.y)
            }

          val ts = collectTargets(att, attX, attY, map.units, wAtt)

          if (ts is Nil()) {
            printString("No targets in range.\n")
            runMenu(map, selected, reachable, moveState,None())
          } else {
            printString("\n=== TARGETS (press number) ===\n")
            printTargets(ts, 1)

            val c2 = newConsole()
            val line2 = readLine(c2)
            closeConsole(c2)


              val idxOpt = parseIntOpt(line2.trim())
              idxOpt match {
                case Some(k) =>
                  val idx0 = k - 1
                  val defOpt = listGet(ts, idx0)   
                  defOpt match {
                    case Some(target) =>
                      activeWeapon(target) match {
                        case Some(wDef) =>

                        
                          val (sx, sy) =
                            moveState match {
                              case Some(Moving(_, sx0, sy0, _, _, _)) => (sx0, sy0)
                              case None() => (att.x, att.y)
                            }

                          val (ax, ay) =
                            moveState match {
                              case Some(Moving(_, _, _, cx, cy, _)) => (cx, cy)
                              case None() => (att.x, att.y)
                            }

                          
                          val attAtCursor =
                            gameUnbit(
                              att.side,
                              ax, ay,
                              att.hp,
                              att.strength, att.magic, att.defense, att.resistance,
                              att.precision, att.agility, att.luck,
                              att.movement,
                              att.weapons,
                              att.activeWeapon,
                              att.moved,
                              att.symbol
                            )

                          val p = previewPure(attAtCursor, target, wAtt, wDef)

                          val cs =
                            CombatState(attAtCursor, sx, sy, ax, ay, target, wAtt, wDef, p)

                          printPreview(cs)
                          runMenu(map, selected, reachable, moveState, Some(cs))

                        case None() =>
                          printString("Defender has no weapon.\n")
                          runMenu(map, selected, reachable, moveState, combatState)
                      }

                      
                    case None() =>
                      printString("Invalid target.\n")
                      runMenu(map, selected, reachable, moveState, None())
                  }

                case None() =>
                  printString("Invalid number.\n")
                  runMenu(map, selected, reachable, moveState, None())
              }
            }

          case None() =>
            printString("No active weapon.\n")
            runMenu(map, selected, reachable, moveState, None())
        }
        }
      case None() =>
        printString("No unit selected.\n")
        runMenu(map, selected, reachable, moveState, None())
    }
  case CancelCombat() =>
    runMenu(map, selected, reachable, moveState, None())

case ConfirmCombat() =>
  try {
    combatState match {
      case None() =>
        runMenu(map, selected, reachable, moveState, None())

      case Some(cs) =>
        
        val att0 = decWeaponUse(cs.attacker)
        val att0AtCursor =
          gameUnbit(
            att0.side,
            cs.attackerX, cs.attackerY,
            att0.hp,
            att0.strength, att0.magic, att0.defense, att0.resistance,
            att0.precision, att0.agility, att0.luck,
            att0.movement,
            att0.weapons,
            att0.activeWeapon,
            true,
            att0.symbol
          )
        val def0 = cs.defender

        activeWeapon(att0) match {
          case None() =>
            runMenu(map, selected, reachable, None(), None())

          case Some(wAttNow) =>
            activeWeapon(def0) match {
              case None() =>
                runMenu(map, selected, reachable, None(), None())

              case Some(wDefNow) =>
                val pAtt = previewPure(att0, def0, wAttNow, wDefNow)
                val r1   = resolveAttack(att0, def0, pAtt)
                val def1 = applyDamage(def0, r1.damage)

                printString(
                  "\nATTACKER: " ++
                  (if (r1.hit) "HIT" else "MISS") ++
                  (if (r1.crit) " (CRIT)" else "") ++
                  " dmg=" ++ r1.damage.show ++ "\n"
                )

                val unitsA =
                  replaceUnit(map.units, cs.attackerStartX, cs.attackerStartY, att0AtCursor)

                
                val units1 =
                  replaceUnit(unitsA, def0.x, def0.y, def1)

                val map1 =
                  GameMap(map.width, map.height, map.tiles, units1)

                if (not(alive(def1))) {
                  printString("Defender defeated.\n")
                  endOrContinue(map1) { mClean =>
                    afterPlayerCombat(mClean)
                  }
                } else {
                  

                  if (canCounter(def1, att0, wDefNow)) {
                    val pDef = previewPure(def1, att0, wDefNow, wAttNow)
                    val r2   = resolveAttack(def1, att0, pDef)
                    val att1 = applyDamage(att0, r2.damage)

                    printString(
                      "DEFENDER: " ++
                      (if (r2.hit) "HIT" else "MISS") ++
                      (if (r2.crit) " (CRIT)" else "") ++
                      " dmg=" ++ r2.damage.show ++ "\n"
                    )

                    val units2 =
                      replaceUnit(map1.units, cs.attackerX, cs.attackerY, att1)

                    val map2   = GameMap(map1.width, map1.height, map1.tiles, units2)

                    endOrContinue(map2) { mClean =>
                      afterPlayerCombat(mClean)
                    }

                  } else {
                    printString("No counterattack.\n")
                    endOrContinue(map1) { mClean =>
                      afterPlayerCombat(mClean)
                    }

                  }
                }
            }
        }
    }
  } with roll { max =>
  val m: Int = if (max <= 0) 1 else max
  val r: Int = randInt(m)   
  resume(r)
}
case EndTurn() =>
  printString("\n--- Enemy Phase ---\n")

  val afterEnemy = enemyPhase(map)

  endOrContinue(afterEnemy) { mAlive =>
    // start of new player turn: reset player moved flags
    val resetUnits = resetMoved(mAlive.units)
    val nextMap = GameMap(mAlive.width, mAlive.height, mAlive.tiles, resetUnits)

    printString("\n--- Player Turn ---\n")
    runMenu(nextMap, None(), Nil(), None(), None())
  }



  

  }




 




  }

