module renderer

import src/model
import src/movement
import src/gamestate
import src/combat
import src/utils


def ansiGray(s: String): String = "\u001b[90m" ++ s ++ "\u001b[0m"
def ansiBold(): String = "\u001b[1m"
def ansiUnderline(): String = "\u001b[4m"
def ansiNoStyle(): String = "\u001b[22m\u001b[24m"
record Cell(char: String, fg: String, bg: String, style: String)
effect DrawTile(x: Int, y: Int, fill: String, outline: String): Unit
effect DrawUnit(x: Int, y: Int, ch: String, color: String): Unit
effect HighlightTile(x: Int, y: Int, color: String): Unit

type Buffer = List[List[Cell]]

def printPreview(cs: CombatState): Unit =
  printString(
    "\n=== COMBAT PREVIEW ===\n" ++
    "Target at (" ++ (cs.defender.x + 1).show ++ "," ++ (cs.defender.y + 1).show ++ ")\n" ++
    "DAMAGE = " ++ cs.preview.dmg.show ++ "\n" ++
    "HIT%   = " ++ cs.preview.hit.show ++ "\n" ++
    "CRIT%  = " ++ cs.preview.crit.show ++ "\n" ++
    "Confirm: f   Cancel: g\n"
   )

//text of a wepaon mod
def weaponModLabel(m: WeaponMod): String =
  m match {
    case NoneMod() => "none"
    case ArmorBreak(amount) => "armor_break(" ++ amount.show ++ ")"
    case ExtraCrit(k) => "crit+" ++ k.show
    case AntiArmor(k) => "anti_armor(" ++ k.show ++ ")"
    case MountedBonus(k) => "mounted(" ++ k.show ++ ")"
  }

def modsToString(ms: List[WeaponMod]): String =
  ms match {
    case Nil() => ""
    case Cons(m, rest) =>
      val head = weaponModLabel(m)
      if (rest is Nil()) head
      else head ++ ", " ++ modsToString(rest)
  }

def printUnitStats(u: gameUnbit): Unit = {
  printString("\n=== UNIT STATS ===\n")
  printString("Side: " ++ u.side ++ "\n")
  printString("Pos: (" ++ u.x.show ++ "," ++ u.y.show ++ ")\n")
  printString("HP: " ++ u.hp.show ++ "\n")
  printString("STR: " ++ u.strength.show ++ "\n")
  printString("MAG: " ++ u.magic.show ++ "\n")
  printString("DEF: " ++ u.defense.show ++ "\n")
  printString("RES: " ++ u.resistance.show ++ "\n")
  printString("MOV: " ++ u.movement.show ++ "\n")
  printString("Class: " ++ showUnitClass(u.class) ++ "\n")
}

def printWeapons(u: gameUnbit): Unit = {
  printString("\n=== WEAPONS ===\n")

  def loop(ws: List[Weapon], idx: Int): Unit =
    ws match {
      case Nil() => ()
      case Cons(w, rest) =>
        val marker =
          if (idx == u.activeWeapon) "-> " else "  "

        w.range match {
          case (r1, r2) =>
            val modsStr =
              if (w.mods is Nil()) ""
              else " MODS=[" ++ modsToString(w.mods) ++ "]"
            val slectionnumber = idx + 1
            printString(
              marker ++
              slectionnumber.show ++ ": " ++ w.name ++
              " ATK=" ++ w.attack.show ++
              " HIT=" ++ w.hit.show ++
              " CRIT=" ++ w.crit.show ++
              " RNG=" ++ r1.show ++ "-" ++ r2.show ++
              " Uses=" ++ w.uses.show ++
              modsStr ++
              "\n"
            )
        }


        loop(rest, idx + 1)
    }

  loop(u.weapons, 0)
}
//foregorund color
def ansiFg(c: String): String =
  c match {
    case "white"  => "\u001b[38;5;231m"
    case "gray"   => "\u001b[38;5;250m"
    case "black"  => "\u001b[38;5;250m"   
    case "red"    => "\u001b[38;5;196m"   
    case "blue"   => "\u001b[38;5;39m"    
    case "yellow" => "\u001b[38;5;226m"
    case _        => "\u001b[38;5;231m"
  }

//backgorund color
def ansiBg(c: String): String =
  c match {
    case "white"  => "\u001b[48;5;252m"
    case "yellow" => "\u001b[48;5;229m"
    case "brown"  => "\u001b[48;5;94m"  
    case "purple" => "\u001b[48;5;60m"

    case "green" => "\u001b[48;5;22m"
    case "gray"  => "\u001b[48;5;240m"
    case "blue"  => "\u001b[44m"
    case "red"   => "\u001b[41m"
    case "black" => "\u001b[40m"
    case _       => "\u001b[48;5;16m"
  }


def ansiReset(): String = "\u001b[0m"

def printBuffer(buf: Buffer): Unit =
  buf match {
    case Nil() => ()
    case Cons(row, rest) =>
      printRow(row)
      println("")
      printBuffer(rest)
  }

def printRow(row: List[Cell]): Unit =
  row match {
    case Nil() => ()
    case Cons(c, rest) =>
      printString(
        ansiBg(c.bg) ++
        c.style ++
        ansiFg(c.fg) ++
        c.char ++
        ansiReset()
      )
      printRow(rest)
  }




def emptyCell(): Cell =
  Cell(" ", "white", "black", "")





def makeRow(w: Int): List[Cell] =
  if (w <= 0) Nil()
  else Cons(emptyCell(), makeRow(w - 1))

def makeBuffer(w: Int, h: Int): Buffer =
  if (h <= 0) Nil()
  else Cons(makeRow(w), makeBuffer(w, h - 1))


def getCell(buf: Buffer, x: Int, y: Int): Cell =
  buf match {
    case Cons(row, rest) =>
      if (y == 0) getRowCell(row, x)
      else getCell(rest, x, y - 1)
    case Nil() => emptyCell()
  }

def getRowCell(row: List[Cell], x: Int): Cell =
  row match {
    case Cons(c, rest) =>
      if (x == 0) c else getRowCell(rest, x - 1)
    case Nil() => emptyCell()
  }

def setCell(
  buf: Buffer,
  x: Int,
  y: Int,
  c: Cell
): Buffer =
  buf match {
    case Nil() => Nil()
    case Cons(row, rest) =>
      if (y == 0)
        Cons(setRowCell(row, x, c), rest)
      else
        Cons(row, setCell(rest, x, y - 1, c))
  }

def setRowCell(row: List[Cell], x: Int, c: Cell): List[Cell] =
  row match {
    case Nil() => Nil()
    case Cons(h, t) =>
      if (x == 0) Cons(c, t)
      else Cons(h, setRowCell(t, x - 1, c))
  }

//handler for rendering rules
def withConsole(
  buffer: Ref[Buffer],
  map: GameMap,
  selected: Option[gameUnbit],
  reachable: List[TilePos],
  moveState: Option[MoveState]
): Unit =
  try {
    buffer.set(makeBuffer(map.width, map.height))
    renderMap(map)
    val reachColor =
  selected match {
    case Some(u) =>
      if (u.side == "player") "blue" else "red"
    case None() =>
      "blue"
  }

reachable.foreach { p =>
  do HighlightTile(p.x, p.y, reachColor)
}

    map.units.foreach { u =>
      val color =
        selected match {
          case Some(s) =>
            if (s.x == u.x && s.y == u.y)
              "yellow"
           else if (u.side == "player")
              (if (u.moved) "black" else "blue")
            else
              "red"

          case None() =>
             if (u.side == "player")
              (if (u.moved) "black" else "blue")
            else
              "red"
        }

      renderUnit(u, color)
    }

   
    moveState match {
      case Some(Moving(_, _, _, x, y, _)) =>
        do HighlightTile(x, y, "black")
      case None() => ()
    }

  }
  with DrawTile { (x, y, fill, _) =>
    buffer.set(
      setCell(buffer.get(), x, y, Cell(".", "white", fill, ""))

    )
    resume(())
  }
  with HighlightTile { (x, y, color) =>
    buffer.set(
      setCell(buffer.get(), x, y, Cell(".", "white", color,""))
    )
    resume(())
  }
  with DrawUnit { (x, y, ch, color) =>
    val bg = getCell(buffer.get(), x, y).bg
    val c =
      if (ch.length() == 0) "?"
      else ch.substring(0, 1)

    
    val style = ansiBold()

    buffer.set(
      setCell(buffer.get(), x, y, Cell(c, color, bg, style))
    )
    resume(())
}

def renderMap(map: GameMap): Unit / { DrawTile } = {
  var y = 0
  map.tiles.foreach { row =>
    var x = 0
    row.foreach { tile =>
      val fill =
        tile match {
          case TileFloor()  => "white"
          case TileWall()   => "gray"
          case TileForest() => "green"
          case TileSand()   => "yellow"
          case TileHills()  => "brown"
          case TileMarsh()  => "purple"
        }

      do DrawTile(x, y, fill, "black")
      x = x + 1
    }
    y = y + 1
  }
}

def printHelp(): Unit = {
  printString(
    "\n=== CONTROLS ===\n" ++
    "q            Quit\n" ++
    "s <SYMBOL>    Select unit by symbol (e.g. s A)\n" ++
    "m            Show movement range / enter move mode\n" ++
    "w/a/s/d      Move cursor (when in move mode)\n" ++
    "r            Confirm move (when in move mode)\n" ++
    "c            Cancel move mode\n" ++
    "t            List targets in range (attack)\n" ++
    "1..9         Switch active weapon (by number)\n" ++
    "x            End turn\n" ++
    "h            Show this help again\n" ++
    "\nCombat confirm:\n" ++
    "f            Confirm combat\n" ++
    "g            Cancel combat\n"
  )
}

def renderUnit(u: gameUnbit, color: String): Unit / { DrawUnit } =
  val ch =
    if (u.symbol.length() == 0) "?"
    else u.symbol.substring(0, 1)
  do DrawUnit(u.x, u.y, ch, color)

// prints the units you can attack
def printTargets(ts: List[gameUnbit], i: Int): Unit =
  ts match {
    case Nil() => ()
    case Cons(u, rest) =>
      printString(
        unitSymbol(u) ++ " " ++ i.show ++
        " at (" ++ (u.x + 1).show ++ "," ++ (u.y + 1).show ++ ")" ++
        " HP=" ++ u.hp.show ++ "\n"
      )
      printTargets(rest, i + 1)
  }

 
